<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于neovim主题因tmux而改变问题</title>
    <link href="/geez6572/2025/02/23/%E5%85%B3%E4%BA%8Eneovim%E4%B8%BB%E9%A2%98%E5%9B%A0tmux%E8%80%8C%E6%94%B9%E5%8F%98%E9%97%AE%E9%A2%98/"/>
    <url>/geez6572/2025/02/23/%E5%85%B3%E4%BA%8Eneovim%E4%B8%BB%E9%A2%98%E5%9B%A0tmux%E8%80%8C%E6%94%B9%E5%8F%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近在kitty上使用tmux时发现neovim的主题配色发生改变，但在关闭tmux后主题配色又正常了。</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20250223225610673.png" alt="image-20250223225610673"></p><p>左边是启动tmux后启动的nvim，右边则是没有启动tmux的nvim，两者的配色有明显的变化。</p><p><strong>解决方案</strong></p><ol><li><p>统一环境变量</p><p>确保环境变量<code>TERM</code>与tmux配置<code>default-terminal</code>保持一致。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $TERM  # 我的输出是 xterm-256color<br></code></pre></td></tr></table></figure><p>在tmux.conf中配置<code>default-terminal</code>为你上面的输出（我这里是xterm-256color）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set -g default-terminal &quot;xterm-256color&quot;<br></code></pre></td></tr></table></figure><p>关闭tmux再测试一遍，如果还不行则进行步骤2.</p></li><li><p>启用真彩色支持</p><p>如果系统支持真彩色，那么在tmux和neovim中都启用真彩色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $COLORTERM   # truecolor<br></code></pre></td></tr></table></figure><p>如果你上面输出是<code>truecolor</code>那么就在tmux.conf中启用真彩色支持。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set -as terminal-overrides &quot;,xterm-256color:Tc&quot;  # 启用真彩色<br></code></pre></td></tr></table></figure><p>并在neovim配置文件中也启用。这里使用的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set termguicolors  # Vimscript写这一行<br>vim.opt.termguicolors = true # lua写这一行<br></code></pre></td></tr></table></figure></li></ol><p>最后应该就能解决这个问题了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>neovim</tag>
      
      <tag>vim</tag>
      
      <tag>nvim</tag>
      
      <tag>theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/geez6572/2025/02/14/emacslisp/"/>
    <url>/geez6572/2025/02/14/emacslisp/</url>
    
    <content type="html"><![CDATA[<p>+++<br>title &#x3D; “emacslisp”<br>date &#x3D; 2022-11-18T22:28:00+08:00<br>lastmod &#x3D; 2022-11-18T22:28:27+08:00<br>draft &#x3D; false<br>author &#x3D; “geezer”<br>+++</p><h2 id="emacs-tutorial"><a href="#emacs-tutorial" class="headerlink" title="emacs tutorial"></a>emacs tutorial</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/geez6572/2025/02/14/orgmode/"/>
    <url>/geez6572/2025/02/14/orgmode/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-“orgmode”date-2022-11-18T22-28-00-08-00author-“geezer”"><a href="#title-“orgmode”date-2022-11-18T22-28-00-08-00author-“geezer”" class="headerlink" title="title &#x3D; “orgmode”date &#x3D; 2022-11-18T22:28:00+08:00author &#x3D; “geezer”"></a>title &#x3D; “orgmode”<br>date &#x3D; 2022-11-18T22:28:00+08:00<br>author &#x3D; “geezer”</h2><h2 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言</title>
    <link href="/geez6572/2025/02/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/geez6572/2025/02/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章寄存器"><a href="#第一章寄存器" class="headerlink" title="第一章寄存器"></a>第一章寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>AX,BX,CX,DX用于存放一般数据,所以称为通用寄存器</p><p>由于8086cup的寄存器为16位,而8088cup寄存器为8位,为了能够与8088cpu兼容所以上述的通用寄存器又可以分为两个8位cpu</p><p>AX可分为AH和AL,BX可分为BH和BL,CX可分为CH和CL,DX可分为DH和DL,</p><h3 id="8086CPU给出物理地址方法"><a href="#8086CPU给出物理地址方法" class="headerlink" title="8086CPU给出物理地址方法"></a>8086CPU给出物理地址方法</h3><p>8086CPU有20位地址总线,而8086CPU又是16为结构,所以8086CPU通过两个16位地址合成的方法以达到20位地址</p><p>(1)CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址：<br>(2)段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；<br>(3)地址加法器将两个16位地址合成为一个20位的物理地址：<br>(4)地址加法器通过内部总线将20位物理地址送入输入输出控制电路；<br>(5)输入输出控制电路将20位物理地址送上地址总线；<br>(6)20位物理地址被地址总线传送到存储器。</p><p><strong>地址加法器采用   物理地址&#x3D;段地址x16+偏移地址</strong></p><p><strong>综上我们可以知道：</strong></p><p>​段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>​8086CPU有4个段寄存器：CS、DS、SS、ES</p><h3 id="CS和IP寄存器"><a href="#CS和IP寄存器" class="headerlink" title="CS和IP寄存器"></a>CS和IP寄存器</h3><p>​cs为代码段寄存器，ip为指令指针寄存器</p><h3 id="修改CS，IP寄存器"><a href="#修改CS，IP寄存器" class="headerlink" title="修改CS，IP寄存器"></a>修改CS，IP寄存器</h3><p><strong>mov</strong>指令是不能对CS和IP寄存器进行赋值的。</p><p>我们可以使用<strong>jmp</strong>指令修改CS和IP寄存器。</p><p>jmp段地址：偏移地址”指令的功能为：用指令中给出的段地址修改CS,偏移地址修改IP。<br>jmp某一合法寄存器”指令的功能为：用寄存器中的值修改IP。</p><h2 id="第二章DOS中使用debug"><a href="#第二章DOS中使用debug" class="headerlink" title="第二章DOS中使用debug"></a>第二章DOS中使用debug</h2><p>用Debug的R命令查看、改变CPU寄存器的内容；<br>用Debug的D命令查看内存中的内容；<br>用Debug的E命令改写内存中的内容：<br>用Debug的U命令将内存中的机器指令翻译成汇编指令；<br>用Debug的T命令执行一条机器指令；<br>用Debug的A命令以汇编指令的格式在内存中写入一条机器指令。</p><h2 id="第三章寄存器（内存访问）"><a href="#第三章寄存器（内存访问）" class="headerlink" title="第三章寄存器（内存访问）"></a>第三章寄存器（内存访问）</h2><h3 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h3><h4 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h4><p>MOV指令用法：</p><ol><li>将数据直接送入寄存器中：</li></ol><p>​<strong>MOV  寄存器  数据</strong></p><ol start="2"><li>将一个寄存器的内容送到另一个寄存器中：</li></ol><p>​<strong>MOV  寄存器   寄存器</strong></p><ol start="3"><li>将一个内存单元的内容送入寄存器中：</li></ol><p>​<strong>MOV    寄存器   [偏移地址]</strong></p><p>当使用第三种方法是会自动将<strong>DS</strong>寄存器中的数据作为段地址，即第三种方法实际上执行的指令为</p><p>​<strong>MOV  寄存器   DS:[偏移地址]</strong> </p><p>其含义为将内存地址为DS:[偏移地址]中的数据送入指定的寄存器</p><h4 id="DS寄存器"><a href="#DS寄存器" class="headerlink" title="DS寄存器"></a>DS寄存器</h4><p>DS寄存器通常用于存放要访问的数据的段地址</p><p>DS寄存器不支持直接使用MOV将数据送入寄存器的方法，但支持使用MOV将其他寄存器的值送入DS寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">#错误写法<br>mov ds,1000H<br><br>#正确写法<br>mov  bx,1000H<br>mov  ds,bx<br></code></pre></td></tr></table></figure><h4 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h4><p>基本操作：push（入栈），pop（出栈）</p><p>注意：8086CPU入栈和出栈操作都是以字为单位进行的</p><p>push ax  表示将寄存器ax中的数据送入栈中</p><p>pop ax  表示从栈顶取数据送入ax寄存器中</p><h4 id="SS-SP寄存器"><a href="#SS-SP寄存器" class="headerlink" title="SS:SP寄存器"></a>SS:SP寄存器</h4><p>SS和SP寄存器时刻指向栈顶元素，当执行push或pop指令时，SS:SP会得到新的栈顶地址,若栈为空,SS:SP指向栈空间最高地址单元的下一单元</p><p>注意：当执行pop指令时实际上此时只会将SS:SP寄存器的值改变，但其实原SS:SP指向的内存中的值并没有消除，当再次进行push操作时会将改值覆盖。</p><p>注意：在使用栈时CPU只知道栈顶在哪（即SS:SP），但并不知道栈的大小，因此我们在编码时需要特别的注意防止栈越界问题。</p><h2 id="第四章第一个程序"><a href="#第四章第一个程序" class="headerlink" title="第四章第一个程序"></a>第四章第一个程序</h2><h3 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h3><h4 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h4><ol><li>xxx segment …  xxx  ends</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">段名 segment<br>.<br>.<br>.<br>段名 ends<br></code></pre></td></tr></table></figure><p>​一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。</p><ol start="2"><li><p>end</p><p>end是一个汇编程序结束的标记，编译器在编译过程中如果碰到伪指令end，就结束对程序的编译</p><p>注意：不要与上面的xxx  ends混淆</p></li><li><p>assume </p><p>它假设某一寄存器与程序中定义的段相连</p></li><li><p>标号</p><p>前面的xxx  segment中的”xxx”就是一个标号，标号代表着一个地址，</p></li><li><p>程序返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;这两条语句再程序末尾使用实现程序返回<br>mov ax,4c00H<br>int 21H<br></code></pre></td></tr></table></figure></li></ol><h2 id="第五章-BX-和Loop指令"><a href="#第五章-BX-和Loop指令" class="headerlink" title="第五章[BX]和Loop指令"></a>第五章[BX]和Loop指令</h2><p>注意：在汇编程序中数据不能以字母开头</p><h4 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;计算2的12次方<br>assume cs:codesg<br><br>codesg segment<br>mov ax,2<br>mov cx,11<br>s:add ax,ax<br>loop s<br>mov ax,4c00H<br>int 21h<br>codesg ends<br>end<br></code></pre></td></tr></table></figure><p>loop指令在执行过程中需要一个标号，例如程序中的 s ，在汇编语言中标号代表一个地址，上程序的标号s即是一个地址，该地址中存放了一条指令 add ax,ax,而上程序中的loop s可理解为loop将标号s处的指令作为loop的循环体，至于loop的循环次数则会由cx寄存器中的值决定，每循环一次loop会使cx中的值减一，直至cx中的值为0，则loop循环结束。</p><h2 id="第六章包含多个段的程序"><a href="#第六章包含多个段的程序" class="headerlink" title="第六章包含多个段的程序"></a>第六章包含多个段的程序</h2><h3 id="dw指令"><a href="#dw指令" class="headerlink" title="dw指令"></a>dw指令</h3><p>dw即define word，其含义为定义字型数据。注意字型数据占2个字节即16位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dw 0123h,0456h,0789h,0abch,0defh,ofedh,0cbah,0987h<br></code></pre></td></tr></table></figure><p>由dw定义的数据会存放在由cs:ip作为开头依次往下的地址中。</p><h3 id="指定程序入口"><a href="#指定程序入口" class="headerlink" title="指定程序入口"></a>指定程序入口</h3><p>由前面dw指令可知dw定义的数据会存放在cs:ip地址中，而cs:ip又是用来存放指令地址的，而此时cs:ip中又存着dw定义的数据，那么如何是cs:ip指向指令的地址呢，我们可以通过指定程序的入口来确定，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment <br>;数据<br> start:<br> ;代码<br>codesg ends<br>end start<br></code></pre></td></tr></table></figure><p>其中start就是程序的入口，end start语句意思就是告诉编译器程序的入口在start标号的位置，所以start其实知识一个标号而已，它并不能决定程序的入口，决定程序入口位置是由end start决定的，当然标号也可以不是start可以使其他。</p><h3 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h3><p>SI和DI寄存器与BX寄存器功能相近，可以作为内存的偏移地址，但不同的是SI和DI不能分成两个8位的寄存器</p><p>并且有了SI和DI寄存器后，我们对内存单元的表示也更加的灵活即使用 <strong>[bx+si]和[bx+di]</strong> 两者含义相差无几</p><p>当然也能够使用 <em><strong>[bx+si+idata]和[bx+di+idata]</strong></em> 的方式</p><p>以下是几种常用的内存单元表示方式：</p><p>​(I)[idata]用一个常量来表示地址，可用于直接定位一个内存单元：<br>​(2)bx]用一个变量来表示内存地址，可用于间接定位一个内存单元：<br>​(3)[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；<br>​(4)[bx+si]用两个变量表示地址；<br>​(S)[bx+si+idata]用两个变量和一个常量表示地址。</p><h2 id="第七章处理数据的两个基本问题"><a href="#第七章处理数据的两个基本问题" class="headerlink" title="第七章处理数据的两个基本问题"></a>第七章处理数据的两个基本问题</h2><h3 id="常用寄存器"><a href="#常用寄存器" class="headerlink" title="常用寄存器"></a>常用寄存器</h3><p>​为了描述上的简洁，在以后的课程中，我们将使用描述性的符号reg来表示一个寄存器，用sreg表示一个段寄存器。<br>​reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di;<br>​sreg的集合包括：ds、ss、cs、eso</p><h4 id="bx，si，di，bp寄存器"><a href="#bx，si，di，bp寄存器" class="headerlink" title="bx，si，di，bp寄存器"></a>bx，si，di，bp寄存器</h4><p>（1）在8086CPU中，只有这四个寄存器能够用在”[…]”中进行内存单元寻址</p><p>（2）在[…]中，这四个寄存器可以单独出现，也可以四种组合出现：bx和si，bx和di，bp和si，bp和di。或以这几种方法加上常数出现。 <strong>切记只能以上面描述的这几种方式出现，其余的都是错的。</strong></p><p>（3）只要在[…]中使用了bp寄存器，而指令中没有显示的给出段地址，段地址就在ss中，其余的都默认在ds中。</p><h4 id="常用的寻址方式"><a href="#常用的寻址方式" class="headerlink" title="常用的寻址方式"></a>常用的寻址方式</h4><p><img src="/geez6572/img/image-20221021212453818.png" alt="image-20221021212453818"></p><h4 id="处理的数据长度"><a href="#处理的数据长度" class="headerlink" title="处理的数据长度"></a>处理的数据长度</h4><p>8086CPU指令可处理两种数据长度即  <strong>byte和word</strong>  。下面说明在哪些情况下进行的是字操作，哪些情况下进行的是字节操作</p><p>（1）通过寄存器指明</p><p>​我们知道，寄存器大小为16位即一个字，而一般寄存器可以分为两个8位寄存器，所以当寄存器为16位时处理的是字操作，当寄存器为8位时处理的是字节操作。</p><p>（2）没有寄存器名的情况</p><p>​可以用X ptr指明内存单元长度，当X为byte时即是字节操作，为word时即是字操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;字操作<br>mov word ptr ds:[0],1<br>inc word ptr [bx]<br>inc word ptr ds:[0]<br>add word ptr [bx],2<br><br>;字节操作<br>mov byte ptr ds:[0],1<br>inc byte ptr [bx]<br>inc byte ptr ds:[0]<br>add byte ptr [bx],2<br></code></pre></td></tr></table></figure><p>（3）其他方法</p><p>​有些指令默认了访问的是字单元还是字节单元，比如，push [1000H] 四就不用指明访问的是字单元还是字节单元，因为push指令只进行字操作。</p><h3 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h3><p>​div是除法指令，使用div做除法的时候应注意以下问题:<br>​(1)除数：有8位和16位两种，在一个reg或内存单元中。<br>​(2)被除数：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放：如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。<br>​(3)结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数：如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p><h3 id="dd伪指令"><a href="#dd伪指令" class="headerlink" title="dd伪指令"></a>dd伪指令</h3><p>​前面我们通过db和dw定义字节型数据和字型数据，dd用来定义dword（double word，双字）型数据的。dword占两个字的空间即四个字节</p><h3 id="操作符dup"><a href="#操作符dup" class="headerlink" title="操作符dup"></a>操作符dup</h3><p>​dup操作符和前面介绍的db，dw，dd伪指令一样是由编译器识别的。同时它也经常与这三个伪指令一起使用，用于进行数据的重复。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;定义了3个字节，它们的值都是0，相当于db 0,0,0<br>db 3 dup (0)<br><br>;定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于db0,1,2,0,1,2,0,1,2。<br>db 3 dup (0,1,2)<br></code></pre></td></tr></table></figure><h2 id="第八章转移指令的原理"><a href="#第八章转移指令的原理" class="headerlink" title="第八章转移指令的原理"></a>第八章转移指令的原理</h2><h3 id="8086CPU转移指令分类"><a href="#8086CPU转移指令分类" class="headerlink" title="8086CPU转移指令分类"></a>8086CPU转移指令分类</h3><p>​前面我们介绍过jmp指令，它可以用于修改ip或同时修改cs，ip寄存器中的内容。</p><h4 id="8086CPU的转移行"><a href="#8086CPU的转移行" class="headerlink" title="8086CPU的转移行"></a>8086CPU的转移行</h4><ol><li>只修改P时，称为段内转移，比如：jmp ax。</li><li>同时修改CS和P时，称为段间转移，比如：jmp10000。</li><li>由于转移指令对P的修改范围不同，段内转移又分为：短转移和近转移。</li><li>短转移P的修改范围为-128~127。</li><li>近转移P的修改范围为-32768~32767。</li></ol><h4 id="8086CPU的转移指令"><a href="#8086CPU的转移指令" class="headerlink" title="8086CPU的转移指令"></a>8086CPU的转移指令</h4><ol><li>无条件转移指令（如：jmp)</li><li>条件转移指令</li><li>循环指令（如：loop)</li><li>过程</li><li>中断</li></ol><h3 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h3><p>​offset它的功能是取得一个标号的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:codesg<br>codesg segment<br>start:mov ax,offset start;相当于mova,0<br>s:mov ax,offset s;相当于mova,3<br>codesq ends<br>end start<br></code></pre></td></tr></table></figure><h3 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h3><h4 id="jmp指令转移的几种方式"><a href="#jmp指令转移的几种方式" class="headerlink" title="jmp指令转移的几种方式"></a>jmp指令转移的几种方式</h4><ol><li><p>直接修改ip或cs:ip的值</p><p>示例：jmp  16位地址  |   jmp 16位地址:16位地址</p><p>作用：将ip的值修改为指定的16位地址，或同时修改cs:ip的值</p><p>注意：jmp 16为地址修改的是ip的值，不能单独修改cs的值</p></li><li><p>依据位移转移</p><p>示例：jmp short 标号 |  jmp near  ptr 标号</p><p>作用：转移到标号处执行指令，前者转移范围在8位，后这转移范围在16位</p><p>原理：将ip的值加上当前ip值与标号处偏移地址的位数（即将ip地址+标号所在地址-jmp指令后一条指令的地址）</p><p>注意：转移使用的是补码形式</p></li><li><p>转移的地址在指令中</p><p>示例：jmp far ptr 标号</p><p>作用：实现段间转移，又称远转移</p><p>原理：修改cs:ip的值使其与标号所在的地址对应</p><p>注意：</p></li><li><p>转移地址在寄存器</p><p>示例：jmp  16位寄存器</p><p>功能：将指定的16位寄存器的值赋值给ip</p></li><li><p>转移地址在内存中</p><p>示例：jmp word ptr 内存单元地址  |   jmp  dword ptr 内存单元地址</p><p>作用：段内转移，将以内存单元为起始地址的两个内存单元中的值赋值给ip |段间转移，将内存单元起始地址开始的前两个内存单元的值赋值给ip，将其后两个内存单元的值赋值给cs</p></li></ol><h3 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h3><p>​有条件的转移指令，所有的有条件转移都是短转移</p><p>示例：jcxz 标号</p><p>条件：判断cx寄存器中的值是否为0，如果为零则转移，否者不做任何事</p><p>作用：cx为时，将ip&#x3D;ip+8位地址</p><h3 id="loop指令-1"><a href="#loop指令-1" class="headerlink" title="loop指令"></a>loop指令</h3><p>​loop为循环指令，所有循环指令都是短转移，其循环方式是判断cx中的值是否为0，不为0则转到标号处执行并使cx减一，否者继续向下执行</p><h2 id="第九章call和ret指令"><a href="#第九章call和ret指令" class="headerlink" title="第九章call和ret指令"></a>第九章call和ret指令</h2><h3 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h3><p>ret指令用栈中的数据，修改ip中的内容，从而实现近转移</p><p>retf指令用栈中的数据，修改cs:ip的值，从而实现远转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;当执行ret指令时等于<br>pop ip<br>;当执行retf指令时等于<br>pop ip<br>pop cs<br></code></pre></td></tr></table></figure><p>注意：以上代码只是为了演示ret和retf指令执行的原理，实际上我们知道cs和ip寄存器的值是不能直接修改的，这也是为什么有jmp，ret，retf等指令的原因。</p><h3 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h3><h4 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h4><p>示例：call  标号</p><p>作用：将当前ip压入栈后，转到标号处执行指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;执行call 标号指令时相当于执行以下指令<br>push ip<br>jmp near ptr 标号<br></code></pre></td></tr></table></figure><h4 id="转移的目的地址在指令中的call指令"><a href="#转移的目的地址在指令中的call指令" class="headerlink" title="转移的目的地址在指令中的call指令"></a>转移的目的地址在指令中的call指令</h4><p>示例：call  far ptr 标号</p><p>作用：实现段间转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;执行此指令时相当于执行以下指令<br>push cs <br>push ip<br>jmp far ptr 标号<br></code></pre></td></tr></table></figure><h4 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h4><p>示例：call  16为寄存器</p><p>作用：将ip压入栈中，在将16位寄存器中的值赋值给ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;执行此指令相当于执行以下指令<br>push ip<br>jmp 16位寄存器<br></code></pre></td></tr></table></figure><h4 id="转移地址在内存中的call指令"><a href="#转移地址在内存中的call指令" class="headerlink" title="转移地址在内存中的call指令"></a>转移地址在内存中的call指令</h4><p>示例：call word ptr 内存单元地址  |   call dword ptr 内存单元地址</p><p>作用：将ip或cs和ip压入栈中，然后将内存地址的值赋值给ip或cs和ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;执行call word ptr 内存单元地址 相当于执行<br>push ip<br>jmp word ptr 内存单元地址<br><br>;执行call dword ptr 内存单元地址 相当于执行<br>push cs<br>push ip<br>jmp dword ptr 内存单元地址<br></code></pre></td></tr></table></figure><h3 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h3><p>​mul指令为乘法指令</p><p>​mul使用的注意事项：</p><pre><code class="hljs">1. 相乘的两个数要么都是八位要么都是16位 ，如果是8位则一个默认放在al寄存器中一个放在8位寄存器中或内存字节单元中；如果是16位则一个默认放在ax寄存器中，一个放在16位寄存器中或16位的内存字单元中。2. 两数相乘的结果如果是8位则默认放在ax寄存器中，如果是16位则高位放在dx寄存器中，低位放在ax寄存器中</code></pre><h2 id="第十章标志寄存器"><a href="#第十章标志寄存器" class="headerlink" title="第十章标志寄存器"></a>第十章标志寄存器</h2><p>标志寄存器是一种特殊的寄存器它有如下作用：</p><p>​用来·存储相关指令的某些结果</p><p>​用来为CPU执行相关指令提供行为依据</p><p>​用来控制CPU的相关工作方式</p><p>标志寄存器各位示意图</p><p><img src="/geez6572/img/image-20221022200545206.png" alt="image-20221022200545206"></p><p>其中1,3,5,12,13,14,15位在8086CPU中未使用，而其他为都具有特殊含义</p><h3 id="常用标志寄存器"><a href="#常用标志寄存器" class="headerlink" title="常用标志寄存器"></a>常用标志寄存器</h3><h4 id="zf标志"><a href="#zf标志" class="headerlink" title="zf标志"></a>zf标志</h4><p>zf标志记录了相关指令执行后其结果是否为0，如果为0那么zf标志为1，否则为0</p><h4 id="pf标志"><a href="#pf标志" class="headerlink" title="pf标志"></a>pf标志</h4><p>pf标志为奇偶标志位，它记录了相关命令执行后其结果的所有位中1的个数是否为偶数，如果1的个数为偶数则pf为1，否则为0</p><h4 id="sf标志"><a href="#sf标志" class="headerlink" title="sf标志"></a>sf标志</h4><p>sf标志为符号标志位，它记录了相关指令执行后，其结果是否为负数，如果结果为负则sf为1，否则为0</p><h4 id="cf标志"><a href="#cf标志" class="headerlink" title="cf标志"></a>cf标志</h4><p>cf标志为进位标志，一般来说在进行无符号运算时，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p><h4 id="of标志"><a href="#of标志" class="headerlink" title="of标志"></a>of标志</h4><p>of标志为溢出标志位，一般情况下它记录了有符号数的运算结果是否发生溢出，如果有则of值为1，否则为0</p><p>注意：cf与of的区别，cf是对无符号运算的有意义的标志位，而of则是对有符号运算有意义的标志位</p><h4 id="df标志"><a href="#df标志" class="headerlink" title="df标志"></a>df标志</h4><p>df标志是方向标志，在串处理指令中，控制每次si，di的增减</p><p>di为0时，每次操作后si和di递增</p><p>di为1是，每次操作后si和di递减</p><h4 id="tf标志"><a href="#tf标志" class="headerlink" title="tf标志"></a>tf标志</h4><p>​程序单步中断标志，CPU执行完一条指令后如果标志寄存器中的tf位的值为1，则会产生单步中断，引发中断过程。在我们前面使用的debug调试的程序使用的就是这种原理，我们在进入debug后若果输入t就会执行一条语句，后在打印各寄存器的情况，等待下一步操作，其原理就是将tf的值设为1。</p><h4 id="if标志"><a href="#if标志" class="headerlink" title="if标志"></a>if标志</h4><p>​用于判断可屏蔽外中断CPU是否可以不响应，为0可不响应，为1则中断。具体的后面会细说</p><p>​设置if标志的值sti设置if值为1，cli设置if值为0</p><h3 id="与标志寄存器相关的指令"><a href="#与标志寄存器相关的指令" class="headerlink" title="与标志寄存器相关的指令"></a>与标志寄存器相关的指令</h3><h4 id="cld指令和std指令"><a href="#cld指令和std指令" class="headerlink" title="cld指令和std指令"></a>cld指令和std指令</h4><p>cld将标志寄存器中的df为设为0</p><p>std将标志寄存器中的df为设为1</p><h4 id="movsb指令"><a href="#movsb指令" class="headerlink" title="movsb指令"></a>movsb指令</h4><p>示例：movsb</p><p>作用：执行movsv指令相当于执行下面几步操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov es:[di],byte ptr ds:[si]  ;在这里仅仅只用于描述，实际上8086CPU并不支持这样的指令<br>;如果df=0<br>inc di<br>inc si<br><br>;如果df=1<br>dec di<br>dec si<br><br></code></pre></td></tr></table></figure><h4 id="movsw指令"><a href="#movsw指令" class="headerlink" title="movsw指令"></a>movsw指令</h4><p>movsw指令与movsb指令作用相同不过movsb传送的是字节而movsw传送的是字,其操作相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov es:[di],word ptr ds:[si]  ;在这里仅仅只用于描述，实际上8086CPU并不支持这样的指令<br>;如果df=0<br>add di,2<br>add si,2<br><br>;如果df=1<br>sub di,2<br>sub si,2<br></code></pre></td></tr></table></figure><h4 id="rep指令"><a href="#rep指令" class="headerlink" title="rep指令"></a>rep指令</h4><p>通常与movsb和movsw使用，其作用是根据cx的值循环执行其后面的指令，例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rep movsb<br>rep movsw<br>;其作用相当于<br>s:movsb<br>loop s<br><br>a:movsw<br>loop a<br></code></pre></td></tr></table></figure><h4 id="pushf和popf指令"><a href="#pushf和popf指令" class="headerlink" title="pushf和popf指令"></a>pushf和popf指令</h4><p>前面我们是到push和pop指令是对栈进行操作，当然pushf和popf也不例外</p><p>pushf指令是将标志寄存器中的值压栈</p><p>popf是从栈中弹出数据并送入标志寄存器</p><h4 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h4><p>adc指令是带进位的加法指令，它利用了cf标志的进位值</p><p>示例：adc  操作对象1  操作对象2 </p><p>功能：操作对象1&#x3D;操作对象1+操作对象2+cf标志的值</p><h4 id="sbb指令"><a href="#sbb指令" class="headerlink" title="sbb指令"></a>sbb指令</h4><p>sbb指令时带位减法指令，它利用了cf标志上的借位置</p><p>示例：sbb  操作对象1  操作对象2 </p><p>功能：操作对象1&#x3D;操作对象1-操作对象2-cf标志的值</p><h4 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h4><p>cmp是比较指令，可以理解为sub指令，不同的是它不会保存结果，但会对标志寄存器产生影响。其用法也与减法指令一样</p><h3 id="检测比较结果的条件转移指令"><a href="#检测比较结果的条件转移指令" class="headerlink" title="检测比较结果的条件转移指令"></a>检测比较结果的条件转移指令</h3><p>前面介绍过条件转移指令jcxz指令，它会根据cx寄存器中的值判断是否修改ip的值</p><p>由此我们也可知道条件转移指令中转移的含义为能够修改ip的值，而条件指它可以根据某个条件决定是否修改ip的值</p><p>下面我们会列出几个基于比较结果的条件指令</p><h4 id="根据无符号数的比较结果进行转移的指令"><a href="#根据无符号数的比较结果进行转移的指令" class="headerlink" title="根据无符号数的比较结果进行转移的指令"></a>根据无符号数的比较结果进行转移的指令</h4><table><thead><tr><th>指令</th><th>含义</th><th>检测的相关标志位</th><th>字母含义</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>zf&#x3D;1</td><td>e:表示equal</td></tr><tr><td>jne</td><td>不等于则转移</td><td>zf&#x3D;0</td><td>ne:表示not equal</td></tr><tr><td>jb</td><td>低于则转移</td><td>cf&#x3D;1</td><td>b:表示below</td></tr><tr><td>jnb</td><td>不低于则转移</td><td>cf&#x3D;0</td><td>nb:表示not below</td></tr><tr><td>ja</td><td>高于则转移</td><td>cf&#x3D;0且zf&#x3D;0</td><td>a:表示above</td></tr><tr><td>jna</td><td>不高于则转移</td><td>cf&#x3D;1或zf&#x3D;1</td><td>na:表示not above</td></tr></tbody></table><h3 id="标志寄存器在Debug中的表示"><a href="#标志寄存器在Debug中的表示" class="headerlink" title="标志寄存器在Debug中的表示"></a>标志寄存器在Debug中的表示</h3><p><img src="/geez6572/img/image-20221022221729888.png" alt="image-20221022221729888"></p><p><img src="/geez6572/img/image-20221022221749341.png" alt="image-20221022221749341"></p><h2 id="第十一章内中断"><a href="#第十一章内中断" class="headerlink" title="第十一章内中断"></a>第十一章内中断</h2><h3 id="内中断产生"><a href="#内中断产生" class="headerlink" title="内中断产生"></a>内中断产生</h3><p>中断信息产生原因</p><table><thead><tr><th>原因</th><th align="left">类型码</th></tr></thead><tbody><tr><td>除法出错</td><td align="left">0</td></tr><tr><td>单步执行</td><td align="left">1</td></tr><tr><td>执行into指令</td><td align="left">4</td></tr><tr><td>执行int指令</td><td align="left">int指令格式为int n，n位立即数，是提供给CPU的类型码</td></tr></tbody></table><h3 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h3><p>中断向量表中存放了256个中断源对应的中断程序处理入口，CPU可根据中断产生的类型码来寻找对应的中断程序处理入口</p><p>8086中断向量表存放在0000:0000到0000：03FF处公1024个单元</p><h3 id="iret指令"><a href="#iret指令" class="headerlink" title="iret指令"></a>iret指令</h3><p>语法描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pop ip<br>pop cs<br>popf<br></code></pre></td></tr></table></figure><h3 id="单步中断"><a href="#单步中断" class="headerlink" title="单步中断"></a>单步中断</h3><p>​在前面介绍tf标志是有提到，单步中断其具体过程如下：</p><ol><li>tf值如果为1</li><li>取得中断码1</li><li>标志寄存器入栈，tf，if的值设为0</li><li>cs，ip入栈</li><li>(ip)&#x3D;(1*4),(cs)&#x3D;(1*4+2)</li></ol><h2 id="第十二章int指令"><a href="#第十二章int指令" class="headerlink" title="第十二章int指令"></a>第十二章int指令</h2><p>​int 指令为中断指令，其格式为“int n”，其中n为立即数，该指令含义为中断程序其中n为中断码。其执行流程如下</p><ol><li>取中断码n</li><li>取得中断码1</li><li>标志寄存器入栈，tf，if的值设为0</li><li>cs，ip入栈</li><li>(ip)&#x3D;(n*4),(cs)&#x3D;(n*4+2)</li></ol><p>编写，安装中断程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">assume cs:code<br><br></code></pre></td></tr></table></figure><h3 id="BISO和DOS启动流程"><a href="#BISO和DOS启动流程" class="headerlink" title="BISO和DOS启动流程"></a>BISO和DOS启动流程</h3><p>​(1)开机后，CPU一加电，初始化(CS)&#x3D;0FFFFH,（IP)&#x3D;0,自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。<br>​(2)初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。<br>​(3)硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的引导。从此将计算机交由操作系统控制。<br>​(4)DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p><h3 id="BISO中断例程"><a href="#BISO中断例程" class="headerlink" title="BISO中断例程"></a>BISO中断例程</h3><p>​int  10h是biso的中断例程，其包含了多个与屏幕输出相关的子程序，使用ah来表示子程序的编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;设置光标的位置<br>mov ah,2;使用2号子程序，置光标<br>mov bh,0;第0页<br>mov dh,5;dh中放行号<br>mov dl，12;dl中放列号<br>int 10h<br><br>;显示字符<br>mov ah,9;使用9号子程序，显示字符<br>mov al,&#x27;a&#x27;;要显示的字符<br>mov bl,7;颜色属性<br>mov bh,0;第0页<br>mov cx,3;字符重复个数<br>int 10h<br><br></code></pre></td></tr></table></figure><p>以上仅展示了bios例程下的两个子程序，实际上其子程序远不止两种</p><h3 id="DOS中断例程"><a href="#DOS中断例程" class="headerlink" title="DOS中断例程"></a>DOS中断例程</h3><p>​“int 21h“是dos的中断例程，这个我们前面每个程序的末尾几乎都有，现在来详细解释下程序结束的后两条指令的意义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;程序返回功能<br>mov ah,4ch;使用第4c号子程序，程序返回<br>mov al,0 ;返回值<br>int 21h<br>;相当于<br>mov ax,4c00h<br>int 21h<br><br>;在光标处显示字符串功能<br>mov ds,字符串段地址<br>mov dx，字符串偏移地址<br>mov ah,9;使用第9号子程序，显示字符串<br>int 21h<br></code></pre></td></tr></table></figure><p>由此可知，我们前面写的程序的结束两条指令的含义为程序返回，返回值为al的值</p><h2 id="第十三章端口"><a href="#第十三章端口" class="headerlink" title="第十三章端口"></a>第十三章端口</h2><p>​在CPU中最多可以定位64kb个不同端口，每个端口占1个字节,64kb即65536个端口，端口地址为0~65535。对端口的读写有两个指令in和out分别对应从端口中读取数据和往端口中写入数据。<strong>且in和out两条指令只能使用al和ax接收端口的数据或写入数据到端口</strong></p><h3 id="shl和shr指令"><a href="#shl和shr指令" class="headerlink" title="shl和shr指令"></a>shl和shr指令</h3><h4 id="shl指令"><a href="#shl指令" class="headerlink" title="shl指令"></a>shl指令</h4><p>示例：shl  内存单元或寄存器，想要移动的位数</p><p>作用：将一个寄存器或内存单元的数据向左移位，将最后一位移除的写入cf</p><h4 id="shr指令"><a href="#shr指令" class="headerlink" title="shr指令"></a>shr指令</h4><p>与shr指令相反</p><p>注意：如果移动位数大于1，则移动位数必须放在cl中</p><h3 id="实验：输出当前时间"><a href="#实验：输出当前时间" class="headerlink" title="实验：输出当前时间"></a>实验：输出当前时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs assembly">;通过端口获取当前日期<br>data segment<br>db 9,8,7,4,2,0<br>data ends<br><br>CODES SEGMENT<br>    ASSUME CS:CODES,ds:data<br>START:<br>mov ax,data<br>mov ds,ax<br>mov si,0<br><br>mov cx,5<br>mov di,160*12+40*2<br>mov bx,0b800h<br>    mov es,bx<br>    mov byte ptr es:[di],&#x27;2&#x27;<br>    mov byte ptr es:[di+2],&#x27;0&#x27;<br>    add di,4<br>s:<br>    mov al,[si]<br>    out 70h,al<br>    in al,71h<br>    mov ah,al<br>    mov dx,cx<br>    mov cl,4<br>    shr ah,cl<br>    mov cx,dx<br>    and al,00001111b<br>    add ah,30h<br>    add al,30h<br>    mov byte ptr es:[di],ah<br>    mov byte ptr es:[di+2],al<br>    mov byte ptr es:[di+4],&#x27;.&#x27;<br>    add di,6<br>    inc si<br>    loop s<br>    <br>    MOV AH,4CH<br>    INT 21H<br>CODES ENDS<br>    END START<br></code></pre></td></tr></table></figure><h2 id="第十四章外中断"><a href="#第十四章外中断" class="headerlink" title="第十四章外中断"></a>第十四章外中断</h2><h3 id="外中断分类"><a href="#外中断分类" class="headerlink" title="外中断分类"></a>外中断分类</h3><h4 id="可屏蔽外中断"><a href="#可屏蔽外中断" class="headerlink" title="可屏蔽外中断"></a>可屏蔽外中断</h4><p>​可屏蔽外中断顾名思义就是CPU可以屏蔽的外中断，是否可屏蔽有if标志决定，0为可屏蔽，1正常中断。</p><h4 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h4><p>​CPU在执行完指令后立即响应，引发中断过程。</p><h2 id="第十五章直接定址表"><a href="#第十五章直接定址表" class="headerlink" title="第十五章直接定址表"></a>第十五章直接定址表</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++ Primer学习笔记</title>
    <link href="/geez6572/2023/09/28/C++%20Primer/"/>
    <url>/geez6572/2023/09/28/C++%20Primer/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h1><h2 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用也即给对象起别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-comment">// ri为i的引用</span><br><span class="hljs-type">int</span> &amp;ri=i;<br></code></pre></td></tr></table></figure><p>引用注意事项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 引用必须时对一个对象的引用</span><br><span class="hljs-type">int</span> &amp;ri=<span class="hljs-number">10</span>; <span class="hljs-comment">//错误</span><br><br><span class="hljs-comment">// 引用必须为同一种类型</span><br><span class="hljs-type">double</span> pi=<span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> &amp;rpi=pi; <span class="hljs-comment">//错误</span><br><br><span class="hljs-comment">// 引用必须要有初始化</span><br><span class="hljs-type">int</span> &amp;ra; <span class="hljs-comment">//错误，为初始化</span><br></code></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指针本身是一个对象，它的值为一个对象的地址，它可以赋值与拷贝。因为是一个对象因此与引用不同，它可以不初始化，指针的定义为“类型 *变量名”,例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br><span class="hljs-comment">// 定义一个变量pa，其类型为int*也即整形指针，其值为a的地址</span><br><span class="hljs-type">int</span> *pa=&amp;a; <span class="hljs-comment">//&amp;a表示取出a的地址</span><br></code></pre></td></tr></table></figure><p>由上可值pa类型为int* 但一般编程习惯是把*号紧邻变量名左边，因为这样容易产生误解，例如在定义多个变量时，事实上int*仅作用于一个变量，而非全部，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* a,b,c;<br><span class="hljs-type">int</span> *a,b,c;<br></code></pre></td></tr></table></figure><p>上面程序第一条语句很多人也许会误以为a，b，c均为int指针，实则不然仅a为int指针；b，c为int类型而非指针。因此通常做法是把*号紧挨于变量左边就像第二条语句一样，就不容易产生误解了。</p><p>利用指针访问对象要使用到 “*”解引用操作符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ival=<span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> *pival=&amp;ival;<br>cout&lt;&lt;*pival&lt;&lt;endl;<br></code></pre></td></tr></table></figure><h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void* 指针"></a>void* 指针</h4><p>void* 指针是一种特殊类型的指针，可以存放任意对象的地址。以下程序是正确的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> obj1=<span class="hljs-number">3.14</span>;<br><span class="hljs-type">void</span>* p=&amp;obj1;<br><span class="hljs-type">int</span> obj2=<span class="hljs-number">2</span>;<br>p=&amp;obj2;<br></code></pre></td></tr></table></figure><p>因为不知道其具体类型是什么，因此不能直接使用解引用符号访问该指针指向的对象。</p><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>通常我们不可能清楚知道每一个表达式的值的类型，auto关键字用于让编译器自己推导表达式类型，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> a=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> b=<span class="hljs-number">3.14</span>;<br></code></pre></td></tr></table></figure><p>这是编译器根据2和3.14能推导出a的类型为int，b的类型为double。<br>auto也能在一条语句同时定义多个变量，但必须要有同一类型，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">3.14</span>; <span class="hljs-comment">//错误，0和3.14类型不同</span><br><span class="hljs-keyword">auto</span> c=<span class="hljs-number">0</span>,d=<span class="hljs-number">4</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-keyword">auto</span> e=<span class="hljs-number">3.24</span>,f=<span class="hljs-number">3.14</span>; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure><h3 id="decltype类型指示符"><a href="#decltype类型指示符" class="headerlink" title="decltype类型指示符"></a>decltype类型指示符</h3><p>其作用是返回操作数的数据类型。在次过程中编译器会分析表达式并得到其类型，却不会计算表达式的值，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">f</span>()) a=b;<br></code></pre></td></tr></table></figure><p>编译器会分析并得到f()函数的返回值类型，但并不会调用f()函数。<br>表达式也可以是一个变量或者一个具体的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> ci=<span class="hljs-number">0</span>,&amp;cj=ci;<br><span class="hljs-keyword">decltype</span>(ci) x=<span class="hljs-number">0</span>;  <span class="hljs-comment">// x类型为const int</span><br><span class="hljs-keyword">decltype</span>(cj) y=x;  <span class="hljs-comment">// y是const int&amp;类型</span><br><span class="hljs-keyword">decltype</span>(cj) z; <span class="hljs-comment">// z为引用类型必须初始化</span><br></code></pre></td></tr></table></figure><p>注意事项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">42</span>,*P=&amp;i,&amp;r=i;<br><span class="hljs-keyword">decltype</span>(r) z; <span class="hljs-comment">//错误 z为引用类型必须初始化</span><br><span class="hljs-keyword">decltype</span>(r<span class="hljs-number">+0</span>) x; <span class="hljs-comment">//正确，x为int类型</span><br><span class="hljs-keyword">decltype</span>(*p) c; <span class="hljs-comment">//错误，c为引用类型必须初始化</span><br><span class="hljs-keyword">decltype</span>((i)) n; <span class="hljs-comment">//错误，n为引用类型必须初始化</span><br><span class="hljs-keyword">decltype</span>(i) m; <span class="hljs-comment">// 正确，m为int类型</span><br></code></pre></td></tr></table></figure><p>上述代码中r为引用类型这是显然的，而r+0很明显是一个具体的int类型的值因此是int类型。<br>值得注意的是，如果表达式为解引用操作，则decltype得到的是引用类型。如上decltype(*p)得到的是引用类型int&amp;，而非int。之所以会这样是因为解引用我们得到的是实实在在的对象，而非数值，我们对解引用后的p进行操作会修改i的值。再者就是变量名加括号和不加括号有时候会得到两种不同类型，如上。</p><h1 id="第三章-字符串，向量和数组"><a href="#第三章-字符串，向量和数组" class="headerlink" title="第三章 字符串，向量和数组"></a>第三章 字符串，向量和数组</h1><h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示对象的集合，里面存放的对象的类型相同，所以vector也常常被称作“容器”。<br>vector是C++中的一个类模板而非类，对于类模板来说只有提供了其他额外信息才能实例化为一个具体的类，以vector为例，vector本身不是类，但在其后面加上一对尖括号里面存放某个类型就成了一个类,比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; ivec;  <span class="hljs-comment">//ivec保存int类型对象</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; c; <span class="hljs-comment">// c保存vector&lt;int&gt;类型</span><br></code></pre></td></tr></table></figure><p>值得注意的是vector虽然能够容纳大部分对象作为其元素，但因为引用不是对象，所以不存在包含引用的vector</p><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h1 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h1><h1 id="第五章-语句"><a href="#第五章-语句" class="headerlink" title="第五章 语句"></a>第五章 语句</h1><h1 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><h4 id="局部静态对象"><a href="#局部静态对象" class="headerlink" title="局部静态对象"></a>局部静态对象</h4><p>有些时候需要令局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义位static类型获得这一对象，成称为局部静态对象。局部静态对象仅在第一次执行时进行初始化，直到程序结束后才被销毁。期间除第一次初始化外，就算多次执行函数也不会产生影响，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_call</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> ctr=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> ++ctr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;++i)&#123;<br><span class="hljs-built_in">count_call</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可以计算函数调用次数，在第一次调用函数时对静态对象ctr进行初始化，之后ctr便一直存在函数count_call的作用域中，期间第二次，第三次…后的”static int ctr&#x3D;0;”这条语句都不会对程序产生影响，因为静态对象只初始化一次，但“++ctr”不是初始化语句且ctr会一直在作用域中所以仍然有效。知道程序结束才会将ctr对象销毁。</p><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><h2 id="特殊通途语言特性"><a href="#特殊通途语言特性" class="headerlink" title="特殊通途语言特性"></a>特殊通途语言特性</h2><h3 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h3><p>内联函数一般比较适用于较小的函数，定义内联函数可以避免函数调用的开销，从而提高运行效率，因为内联函数通常是在其每个调用点内联的展开，有点类似于宏，比如以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cout&lt;&lt;<span class="hljs-built_in">test</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>“cout&lt;&lt;test(3,4)&lt;&lt;endl;”这条语句在编译过程中因为test为内联函数所以会在其调用点内联展开为以下形式<br>“cout&lt;&lt;3&gt;4?3:4&lt;&lt;endl”</p><p>constexpr函数指用于常量表达式的函数，其定义方法与普通函数类似，不过要遵循几条约定：函数返回值类型和形参类型都必须为字面值类型，而且函数体中必须有且仅有一条return语句。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向函数而非对象，和其他指针一样，函数指针指向某种特定的函数类型，函数类型由它的返回值和形参类型共同决定而与函数名无关。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//比较两个数大小</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br></code></pre></td></tr></table></figure><p>此函数类型为”bool compare(int,int)”，若想定义一个指向该函数的指针，用指针替换函数名即可，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">bool</span> (*pf)(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>); <span class="hljs-comment">//未初始化</span><br></code></pre></td></tr></table></figure><p>关于函数指针的复制和初始化，当使用函数名作为值时，该函数会自动转换为指针，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pf=compare;<br>pf=&amp;compare;<br></code></pre></td></tr></table></figure><p>在compare为一个函数名时以上两条语句是等价的‘&amp;’可写可不写</p><h3 id="函数指针形参"><a href="#函数指针形参" class="headerlink" title="函数指针形参"></a>函数指针形参</h3><h1 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h1><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><h4 id="将非成员函数作为友元"><a href="#将非成员函数作为友元" class="headerlink" title="将非成员函数作为友元"></a>将非成员函数作为友元</h4><p>类可以允许其他类或者函数访问其私有成员，方法是令其他类或者函数定义为它的友元(friend)，把函数作为友元的方法是增加一条以friend关键字开头的函数声明即可，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> test&amp;,<span class="hljs-type">const</span> test&amp;)</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> test&amp;,<span class="hljs-type">const</span> test&amp;)</span></span>&#123;<br>....函数体...<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码中如果不加‘friend int compare(const test&amp;,const test&amp;);‘这条语句，显然compare函数不属于test类，则它无法访问test私有成员，如果加上的话那么compare函数就成了test的友元，就能够访问其私有成员了。</p><h4 id="将其他类作为友元"><a href="#将其他类作为友元" class="headerlink" title="将其他类作为友元"></a>将其他类作为友元</h4><p>将other类作为test类的友元，other类将具有访问test私有成员的能力</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">other</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将其他类中某个成员函数作为友元"><a href="#将其他类中某个成员函数作为友元" class="headerlink" title="将其他类中某个成员函数作为友元"></a>将其他类中某个成员函数作为友元</h4><p>将other类中某个成员函数作为友元，该函数将具有访问test私有成员的能力，但该类的其他函数不行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">test::compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>委托构造函数是指使用该类其他构造函数执行自己初始化过程的函数，在委托函数内成员初始列表仅有一个入口就是类名本身。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale_data</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 非委托构造函数</span><br><span class="hljs-built_in">Sale_data</span>(<span class="hljs-type">char</span> c,<span class="hljs-type">int</span> b,<span class="hljs-type">double</span> b):<span class="hljs-built_in">bookNo</span>(b),<span class="hljs-built_in">a</span>(c),<span class="hljs-built_in">price</span>(b)&#123;&#125;<br><span class="hljs-comment">// 委托构造函数使用非委托构造函数初始化</span><br><span class="hljs-built_in">Sale_data</span>():<span class="hljs-built_in">Sale_data</span>(<span class="hljs-string">&#x27;&#x27;,0,0.0)&#123;&#125;</span><br><span class="hljs-string">Sale_data(char c):Sale_data(c,0,0.0)&#123;&#125;</span><br><span class="hljs-string">&#125;;</span><br></code></pre></td></tr></table></figure><h1 id="第八章-IO库"><a href="#第八章-IO库" class="headerlink" title="第八章 IO库"></a>第八章 IO库</h1><h1 id="第九章-顺序容器"><a href="#第九章-顺序容器" class="headerlink" title="第九章 顺序容器"></a>第九章 顺序容器</h1><h1 id="第十章-泛型算法"><a href="#第十章-泛型算法" class="headerlink" title="第十章 泛型算法"></a>第十章 泛型算法</h1><h1 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h1><h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>C+动态内存管理可以通过new和delete来完成，不过这种方式极其难以管理因此C11引入了智能指针shared_ptr,unique_ptr,weak_ptr。三种指针均在memory头文件中。</p><h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>shared_ptr类通vector一样也是模板，因为我们也需要知道一个指针到底指向的是什么类型，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">shared_ptr&lt;string&gt; p1;<br>shared_ptr&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; p2;<br></code></pre></td></tr></table></figure><p>如上所示定义了一个指向string和指向vector&lt;int&gt;类型学的指针</p><h4 id="make-shared函数"><a href="#make-shared函数" class="headerlink" title="make_shared函数"></a>make_shared函数</h4><h1 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h1><h2 id="拷贝，赋值与销毁"><a href="#拷贝，赋值与销毁" class="headerlink" title="拷贝，赋值与销毁"></a>拷贝，赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则该该构造函数为拷贝构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">test</span>(<span class="hljs-type">const</span> test&amp;);<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> no;<br>string name;<br>&#125;;<br><br>test::<span class="hljs-built_in">test</span>(<span class="hljs-type">const</span> test&amp; orig):<span class="hljs-built_in">no</span>(orig.no),<span class="hljs-built_in">name</span>(orig.name)&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h3><p>直接初始化是指要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。而拷贝初始化是将右侧运算对象拷贝到正在创建的对象中，需要的话还要进行类型转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">dots</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;.&#x27;</span>)</span></span>; <span class="hljs-comment">//直接初始化</span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(dots)</span></span>;  <span class="hljs-comment">//直接初始化</span><br>string s2=dots;  <span class="hljs-comment">//拷贝初始化</span><br>string s3=<span class="hljs-string">&quot;fdafa&quot;</span> <span class="hljs-comment">//拷贝初始化</span><br></code></pre></td></tr></table></figure><h3 id="拷贝初始化发生情况"><a href="#拷贝初始化发生情况" class="headerlink" title="拷贝初始化发生情况"></a>拷贝初始化发生情况</h3><ol><li>使用‘&#x3D;‘复制时</li><li>将一个对象作为实参传给非引用类型的形参 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">9</span>;<br><span class="hljs-built_in">test</span>(a); <span class="hljs-comment">//这里就发生了拷贝初始化</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>从一个返回值类型为非引用类型返回一个对象 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">9</span>;<br><span class="hljs-keyword">return</span> a; <span class="hljs-comment">//发生拷贝初始化</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>使用花括号初始化数组的元素或聚合类成员</li></ol><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>当一个对象被销毁时会自动调用析构函数，析构函数由 ~类名 定义，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br><span class="hljs-keyword">public</span>:<br>~<span class="hljs-built_in">Test</span>()&#123;&#125; <span class="hljs-comment">// 析构函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>通常来说大多数情况不会用到阻止拷贝，但也有特例如在iostream中就应该阻止拷贝以避免多个对象读取相同的io.<br>在新标准下通常可以将拷贝函数和拷贝赋值函数定义为删除的函数以阻止拷贝赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NoCopy</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">NoCopy</span>(<span class="hljs-type">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">//阻止拷贝</span><br>NoCopy &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> NoCopy&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">//阻止赋值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在新标准前一般是将拷贝函数定义为private以阻止拷贝</p><h1 id="第十四章-重载运算符与类型转换"><a href="#第十四章-重载运算符与类型转换" class="headerlink" title="第十四章 重载运算符与类型转换"></a>第十四章 重载运算符与类型转换</h1><h1 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h1><h2 id="OOP概述"><a href="#OOP概述" class="headerlink" title="OOP概述"></a>OOP概述</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>通过<em>继承</em>联系在一起的类构成一种层次关系。通常在层次的根部有一个基类，其他所有类都直接或间接从基类继承而来，这些类称为派生类。<br>在C++中对于某些函数基类希望派生类都实现自己适合的版本，此时就将基类这些函数定义为<em>虚函数</em>。也就是说如果子类必须对父类的虚函数进行重写。这也是虚函数与普通函数的区别，普通函数若子类不重写则会使用父类的版本，而虚函数必须重写。(类似与java中@override注释)</p><h3 id="动态绑定-多态"><a href="#动态绑定-多态" class="headerlink" title="动态绑定(多态)"></a>动态绑定(多态)</h3><p>通过动态绑定我们可以使一段代码既可以处理父类对象也可以处理子类对象，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span>&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>:Fruit&#123;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Oringe</span>:Fruit&#123;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> Fruit &amp;a)</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在上段代码中Apple和Oringe都继承自Fruit,所以在test中以Fruit对象为参数的函数Fruit，Apple,Oringe对象均可作为其参数。</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>前面已经学习了两种访问控制关键字：public，private。其中public可以允许可他对象访问自己成员，而private则不允许其他对象访问自己成员包括子类，那么如果我们希望子类能够访问其成员而其他类对象不能访问该如何做，这是就要用到protected关键字了。</p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++八股文</title>
    <link href="/geez6572/2023/09/28/C++%E5%85%AB%E8%82%A1%E6%96%87/"/>
    <url>/geez6572/2023/09/28/C++%E5%85%AB%E8%82%A1%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="C-C-篇"><a href="#C-C-篇" class="headerlink" title="C&#x2F;C++篇"></a>C&#x2F;C++篇</h1><h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li><p>修饰变量，说明该变量不可以被改变；</p><p>用作变量是如果变量是基本数据类型那么const的位置不影响变量类型，都表示改变量不可变。</p></li><li><p>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</p><p>若修饰的是指针则const位置显得尤为重要，具体分为指针常量和常量指针。</p></li><li><p>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</p><p>有引用常量，没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰。</p></li><li><p>修饰成员函数，说明该成员函数内不能任何非<code>mutable</code>成员变量。</p></li><li><p>修饰非基本数据类型(比如string之类的，还有我们自己写的类)，对于这类变量来说改变意味着改变其成员变量，不改变也就是不改变成员变量，也就是说若用cosnt修饰的话，它就不能改变成员变量，而要确保它不改变成员变量，那么它就不能访问非cosnt成员函数，因为若允许它访问非const修饰的成员函数，那么它可能通过该函数间接修改成员变量，所以它只能访问const成员函数，在根据const成员函数能修改mutable变量值，所以它也能修改mutable变量的值。</p></li><li><p>非基本数据类型使用const修饰在实例化对象时的问题。一个const修饰的非基本数据类型，其成员变量隐式地是<code>const</code>的。对与const成员变量必须进行初始化。具体例子看下面</p></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 修饰变量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a是常量整数</span><br><span class="hljs-type">int</span> <span class="hljs-type">const</span> b = <span class="hljs-number">20</span>; <span class="hljs-comment">// b也是常量整数，与a等价</span><br><br><br><span class="hljs-comment">// 修饰指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* ptr1 = &amp;a; <span class="hljs-comment">// ptr1指向一个常量整数</span><br><span class="hljs-type">int</span> * <span class="hljs-type">const</span> ptr2 = &amp;a; <span class="hljs-comment">// ptr2是一个指向整数的常量指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> ptr3 = &amp;a; <span class="hljs-comment">// ptr3是一个指向常量整数的常量指针</span><br><br><br><span class="hljs-comment">// 修饰引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref1 = a; <span class="hljs-comment">// ref1是一个对常量整数的引用</span><br><span class="hljs-type">int</span>&amp; <span class="hljs-type">const</span> ref2 = a; <span class="hljs-comment">// 错误，引用本身只是对象的一个别名，而不是对象</span><br><br><br><span class="hljs-comment">// 修饰成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 常量成员函数</span><br>        value=<span class="hljs-number">99</span>； <span class="hljs-comment">// 正确，能修改value的值，因为value被mutable修饰</span><br>        value2=<span class="hljs-number">88</span>；<span class="hljs-comment">// 错误，不能修改value2的值</span><br>        <span class="hljs-keyword">return</span> value; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123; value = v; &#125;    <span class="hljs-comment">// 非常量成员函数</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value; <span class="hljs-comment">// mutable成员可以在const上下文中被修改</span><br>    <span class="hljs-type">int</span> value2；<br>&#125;;<br><br><span class="hljs-comment">// 修饰一个非基本数据类型的引用(或指针)，使用了上面的MyClass类</span><br><span class="hljs-comment">// 这时对象仅能调用const成员函数或访问成员变量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; mc)</span></span>&#123;<br>    mc.<span class="hljs-built_in">getValue</span>(); <span class="hljs-comment">// 正确，getValue函数是const成员函数</span><br>    mc.<span class="hljs-built_in">setValue</span>(); <span class="hljs-comment">// 错误，setValue函数不是cosnt成员函数</span><br>    cout&lt;&lt;mc.value2&lt;&lt;endl; <span class="hljs-comment">// 正确，可以访问成员变量</span><br>    mc.value2++; <span class="hljs-comment">// 错误，不能修改成员变量</span><br>&#125;<br><br><span class="hljs-comment">// 非基本数据类型使用const修饰在实例化对象时的问题。</span><br><span class="hljs-comment">// 在下面代码中使用`const Test t2;`时说明t2为const变量，而即便value1未显示声明为const，因为t2是const所以t2中成员变量value1也会隐式声明为const，根据前面所学const成员变量必须进行初始化，而编译器默认生成的构造函数是不会对const成员初始化的，所以在下面代码中`const Test t2`会报错。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-type">int</span> value1;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Test t1; <span class="hljs-comment">// 正常，编译器生成的默认构造函数会进行默认初始化</span><br>  <span class="hljs-type">const</span> Test t2; <span class="hljs-comment">// 错误，未初始化的const对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 修改，可以把value1也声明成mutable类型，也可以自己加上构造函数进行初始化</span><br><span class="hljs-comment">// 方案一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value1;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value2;<br>&#125;<br><span class="hljs-comment">// 方案二 注意构造函数两种写法，第一种写法才是初始化，第二种写法是赋值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-built_in">Test</span>():<span class="hljs-built_in">value1</span>(<span class="hljs-number">0</span>)&#123;&#125; <span class="hljs-comment">// 不一定是0，可以是其他值</span><br>    <br>    <span class="hljs-comment">// 可以使用Test t1; 但不能使用const Test t2; 因为这种方法是在赋值，而在const Test t2;中value1已经被隐式声明为const所以不能被赋值或修改，只能初始化</span><br>    <span class="hljs-built_in">Test</span>()&#123;<br>        value1=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> value1;<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> value2;<br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是上面const修饰的是成员函数，上面getValue是非成员函数，那实际上上述这种const修饰没有意义。</p><h3 id="宏定义-define-和-const-常量"><a href="#宏定义-define-和-const-常量" class="headerlink" title="宏定义 #define 和 const 常量"></a>宏定义 #define 和 const 常量</h3><table><thead><tr><th>宏定义 #define</th><th>const 常量</th></tr></thead><tbody><tr><td>宏定义，相当于字符替换</td><td>常量声明</td></tr><tr><td>预处理器处理</td><td>编译器处理</td></tr><tr><td>无类型安全检查</td><td>有类型安全检查</td></tr><tr><td>不分配内存</td><td>要分配内存</td></tr><tr><td>存储在代码段</td><td>存储在数据段</td></tr><tr><td>可通过 <code>#undef</code> 取消</td><td>不可取消</td></tr></tbody></table><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol><li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ol><h2 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h2><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>inline 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 声明1（加 inline，建议使用）</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 声明2（不加 inline）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span></span>;<br><br><span class="hljs-comment">// 定义</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">functionName</span><span class="hljs-params">(<span class="hljs-type">int</span> first, <span class="hljs-type">int</span> second,...)</span> </span>&#123;<span class="hljs-comment">/****/</span>&#125;;<br><br><span class="hljs-comment">// 类内定义，隐式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;         <span class="hljs-comment">// 隐式内联</span><br>&#125;<br><br><span class="hljs-comment">// 类外定义，需要显式内联</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">doA</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">A::doA</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;   <span class="hljs-comment">// 需要显式内联</span><br></code></pre></td></tr></table></figure><h3 id="编译器对-inline-函数的处理步骤"><a href="#编译器对-inline-函数的处理步骤" class="headerlink" title="编译器对 inline 函数的处理步骤"></a>编译器对 inline 函数的处理步骤</h3><ol><li>将 inline 函数体复制到 inline 函数调用点处； </li><li>为所用 inline 函数中的局部变量分配内存空间； </li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li></ol><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点</p><ol><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ol><p>缺点</p><ol><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ol><h2 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h2><p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p><p>assert() 使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDEBUG          <span class="hljs-comment">// 加上这行，则 assert 不可用</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-built_in">assert</span>( p != <span class="hljs-literal">NULL</span> );    <span class="hljs-comment">// assert 不可用</span><br></code></pre></td></tr></table></figure><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof()"></a>sizeof()</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>sizeof 对基本数据类型，得到的大小就是这个数据类型占用大小(例如一般来说：char-&gt;1,bool-&gt;1,int-&gt;4,double-&gt;8。这里是说一般情况具体根据编译器不同又所变化)</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>sizeof 对数组，得到整个数组所占空间大小。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>sizeof 对指针，得到指针本身所占空间大小(64位-&gt;8,32位-&gt;4)。</p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>这个是重点，struct数据类型的大小不一定就等于struct所有成员大小之和，因为在分配内存是会存在内存对齐。</p><p>内存对齐中术语：</p><ol><li><p>内存对齐系数</p><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认”#pragma pack(8)”(不一定就是4依系统而定)，可以通过预编译命令#pragma pack(n)，n &#x3D; 1,2,4,8,16来改变这一系数。</p></li><li><p>有效对齐值</p><p>有效对齐值给定值#pragma pack(n)和结构体中最长对齐长度(alignof最大值)中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p></li></ol><p>内存对齐规则:</p><ol><li>结构体第一个成员的<strong>偏移量（offset）<strong>为0，以后每个成员相对于结构体首地址的 offset 都是</strong>该成员大小与有效对齐值中较小那个</strong>的整数倍，如有需要编译器会在成员之间加上填充字节。</li><li><strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</li></ol><p>举几个例子</p><p>下面例子中基本数据类型大小均按照一般64位系统中的大小(char-&gt;1,bool-&gt;1,short-&gt;2,int-&gt;4,double-&gt;8…)。</p><p>还有就是0可以使任何数的整数倍。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aa</span>&#123;</span><br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">char</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有效对齐值：aa中最长数据对齐长度(int-&gt;4)&lt;&#x3D;内存对齐系数”#pragma pack(8)”,所以该值为4。</p><p>规则1:</p><p>sizeof(a)&#x3D;&#x3D;1&lt;&#x3D;有效对齐值4，按照1对齐，首地址的 offset 是1的倍数即0，占用0号单元。</p><p>sizeof(b)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值4，按照4对齐，首地址的 offset 是4的倍数即4，占用4，5，6，7单元。</p><p>sizeof(c)&#x3D;&#x3D;1&lt;&#x3D;有效对齐值4，按照1对齐，首地址的 offset 是1的倍数即1，占用8号单元。</p><p>规则2:</p><p>目前整体大小为9，9不是有效对齐值4的倍数须调整，即调整到12。</p><p>所以sizeof(struct aa)&#x3D;&#x3D;12。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bb</span>&#123;</span><br>    <span class="hljs-type">char</span> a;<br>    <span class="hljs-type">char</span> b;<br>    <span class="hljs-type">int</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有效对齐值：aa中最长数据对齐长度(int-&gt;4)&lt;&#x3D;内存对齐系数”#pragma pack(8)”,所以该值为4。</p><p>规则1:</p><p>sizeof(a)&#x3D;&#x3D;1&lt;&#x3D;有效对齐值4，按照1对齐，首地址的 offset 是1的倍数即0，占用0号单元。</p><p>sizeof(b)&#x3D;&#x3D;1&lt;&#x3D;有效对齐值4，按照1对齐，首地址的 offset 是1的倍数即1，占用1号单元。</p><p>sizeof(c)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值4，按照4对齐，首地址的 offset 是4的倍数即4，占用4，5，6，7单元。</p><p>规则2:</p><p>目前整体大小为8，8是有效对齐值4的倍数无须调整。</p><p>所以sizeof(struct aa)&#x3D;&#x3D;8。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cc</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>    <span class="hljs-type">int</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>有效对齐值：aa中最长数据对齐长度(double-&gt;8)&lt;&#x3D;内存对齐系数”#pragma pack(8)”,所以该值为8。</p><p>规则1:</p><p>sizeof(a)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即0，占用0,1,2,3号单元。</p><p>sizeof(b)&#x3D;&#x3D;8&lt;&#x3D;有效对齐值8，按照8对齐，首地址的 offset 是8的倍数即8，占用8,9…15号单元。</p><p>sizeof(c)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即16，占用16，17，18，19单元。</p><p>规则2:</p><p>目前整体大小为20，20不是有效对齐值8的倍数须调整，调整到24。</p><p>所以sizeof(struct aa)&#x3D;&#x3D;24。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dd</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">double</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>有效对齐值：aa中最长数据对齐长度(double-&gt;8)&lt;&#x3D;内存对齐系数”#pragma pack(8)”,所以该值为8。</p><p>规则1:</p><p>sizeof(a)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即0，占用0,1,2,3号单元。</p><p>sizeof(b)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即4，占用4,5,6,7号单元。</p><p>sizeof(c)&#x3D;&#x3D;8&lt;&#x3D;有效对齐值8，按照8对齐，首地址的 offset 是8的倍数即8，占用8,9..15单元。</p><p>规则2:</p><p>目前整体大小为16，16是有效对齐值8的倍数无须调整。</p><p>所以sizeof(struct aa)&#x3D;&#x3D;16。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">temp</span>&#123;</span><br>    <span class="hljs-type">double</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ee</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">temp</span> <span class="hljs-title">c</span>;</span><br>    <span class="hljs-type">double</span> d;<br>&#125;<br></code></pre></td></tr></table></figure><p>有效对齐值：aa中最长数据对齐长度(struct temp-&gt;8)&lt;&#x3D;内存对齐系数”#pragma pack(8)”,所以该值为8。</p><p>规则1:</p><p>sizeof(a)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即0，占用0,1,2,3号单元。</p><p>sizeof(b)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即4，占用4,5,6,7号单元。</p><p>sizeof(c)&#x3D;&#x3D;16&gt;&#x3D;有效对齐值8，按照8对齐，首地址的 offset 是8的倍数即8，占用8,9..23单元。</p><p>sizeof(c)&#x3D;&#x3D;8&lt;&#x3D;有效对齐值8，按照8对齐，首地址的 offset 是8的倍数即24，占用24,25..31单元。</p><p>规则2:</p><p>目前整体大小为32，32是有效对齐值8的倍数无须调整。</p><p>所以sizeof(struct aa)&#x3D;&#x3D;32。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">temp</span>&#123;</span><br>    <span class="hljs-type">double</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ee</span>&#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">temp</span> <span class="hljs-title">b</span>;</span><br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-type">double</span> d;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有效对齐值：aa中最长数据对齐长度(struct temp-&gt;8)&gt;&#x3D;内存对齐系数”#pragma pack(8)”,所以该值为8。</p><p>规则1:</p><p>sizeof(a)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即0，占用0,1,2,3号单元。</p><p>sizeof(b)&#x3D;&#x3D;16&gt;&#x3D;有效对齐值8，按照8对齐，首地址的 offset 是8的倍数即8，占用8,9..23单元。</p><p>sizeof(c)&#x3D;&#x3D;4&lt;&#x3D;有效对齐值8，按照4对齐，首地址的 offset 是4的倍数即4，占用24,25,26,27单元。</p><p>sizeof(c)&#x3D;&#x3D;8&lt;&#x3D;有效对齐值8，按照8对齐，首地址的 offset 是8的倍数即32，占用32,33..39单元。</p><p>规则2:</p><p>目前整体大小为40，40是有效对齐值8的倍数无须调整。</p><p>所以sizeof(struct aa)&#x3D;&#x3D;40。</p><h2 id="alignof"><a href="#alignof" class="headerlink" title="alignof"></a>alignof</h2><p>可查看有效对齐值，通常用于结构体，对基本数据类型而言alignof就是其本身大小。对struct而言上节已经讲过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">aa</span>&#123;</span><br>    type1 a1;<br>    type2 a2;<br>    .<br>    .<br>    .<br>    typen an;<br>&#125;;<br><span class="hljs-keyword">alignof</span>(结构体)=max(<span class="hljs-keyword">alignof</span>(a1),<span class="hljs-keyword">alignof</span>(a2),...,<span class="hljs-keyword">alignof</span>(an));<br></code></pre></td></tr></table></figure><p>值得注意的是alignof(数组名)时，其大小不是数组大小，而是其数组中元素的大小。例如int arr[10];使用alignof(arr)&#x3D;&#x3D;4;</p><h2 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h2><p>当定义模板类时，模板函数的定义必须与声明在同一个头文件中。原因是模板类和模板函数在编译时不会实例化，只有在使用时才会实例化。因此，编译器需要在使用模板类或模板函数时能够看到其完整定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// node.h文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br>&#125;;<br><br><span class="hljs-comment">// node.cpp文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Node::setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;value=value;<br>&#125;<br><br><span class="hljs-comment">// main.cpp文件</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Node node;<br>    node-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码是正确的，但当Node为模板类时再想将Node的声明放在node.h而将Node的定义放在node.cpp就会出问题，例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// node.h文件</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(K value)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    K value;<br>&#125;;<br><br><span class="hljs-comment">// node.cpp文件</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-type">void</span> Node&lt;K&gt;::<span class="hljs-built_in">setValue</span>(K value)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;value=value;<br>&#125;<br><br><span class="hljs-comment">// main.cpp文件</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Node&lt;<span class="hljs-type">int</span>&gt; node;<br>    node-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时就会编译<code>g++ node.cpp main.cpp -o main</code>就会报错:</p><p><code>undefined reference to Node&lt;int&gt;::setValue(int)&#39;</code>。</p><p>这是必须将声明和定义都写在node.h中像下面这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// node.h文件</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(K value)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    K value;<br>&#125;;<br><span class="hljs-comment">// 注意以下这个函数也在node.h中</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K&gt;<br><span class="hljs-type">void</span> Node&lt;K&gt;::<span class="hljs-built_in">setValue</span>(K value)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;value=value;<br>&#125;<br><br><span class="hljs-comment">// main.cpp文件</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Node&lt;<span class="hljs-type">int</span>&gt; node;<br>    node-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就能成功编译通过</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++标准库学习</title>
    <link href="/geez6572/2023/09/28/C++%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <url>/geez6572/2023/09/28/C++%E6%A0%87%E5%87%86%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><h2 id="at和operator"><a href="#at和operator" class="headerlink" title="at和operator[]"></a>at和operator[]</h2><p>at会检测边界，而operator[]不会</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用at</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    array&lt;<span class="hljs-type">int</span>,5&gt; arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout&lt;&lt;arr.<span class="hljs-built_in">at</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 使用operator[]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    array&lt;<span class="hljs-type">int</span>,5&gt; arr=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    cout&lt;&lt;arr[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>就上面的例子来说，5很明显超出边界了，若使用at的话因为会检测边界，所有会报错；若使用operator[]的话不会报错会输出一个未知数字，具体未知，因为它已经访问到arr之外的内存了，这是很危险的。</p><h2 id="关于front和back"><a href="#关于front和back" class="headerlink" title="关于front和back"></a>关于front和back</h2><p>注意front和back返回的是引用类型，若容器是const修饰的，则返回const的引用。这里比较易于出错的在于会以为返回值是容器元素类型，但其实是引用。</p><h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>返回指向容器第一个对象的指针</p><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p>将容器元素填充为某个值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">array&lt;<span class="hljs-type">int</span>,5&gt; arr；<br><span class="hljs-comment">// 将arr元素均填充为10</span><br>arr.<span class="hljs-built_in">fill</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h2 id="rbegin-和rend"><a href="#rbegin-和rend" class="headerlink" title="rbegin()和rend()"></a>rbegin()和rend()</h2><p>返回一个容器的反向迭代器,具体来说rbegin()得到的是指向最后一个元素的反向迭代器,而rend会得到第一个元素的反向迭代器。也就是将最后一个元素当作第一个元素。当使用逆向迭代器时，操作符 <code>++</code> 实际上是使内部普通迭代器向前移动一位，但由于是逆向迭代器，看起来就像是在向后遍历。</p><p>值得注意的点是正向迭代器与反向迭代器是不同的类型，不能进行比较。这里会比较容易出错，就像下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> rit = vec.<span class="hljs-built_in">rbegin</span>(); rit != vec.<span class="hljs-built_in">begin</span>(); ++rit) &#123;<br>    std::cout &lt;&lt; *rit &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能会认为rend和begin都是指向第一个元素的迭代器，以为两者相同，但注意rbegin是返回<em>反向迭代器</em>，这是不同的</p><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><h2 id="size和max-size"><a href="#size和max-size" class="headerlink" title="size和max_size"></a>size和max_size</h2><p>这里的size和max_size由于容器是可以扩充,所以其max_size大小通常很大(取决于系统内存)</p><h2 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span> <span class="hljs-params">(size_type n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resize</span> <span class="hljs-params">(size_type n, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br></code></pre></td></tr></table></figure><p>调整deque大小到n,若n&gt;size此时分两种情况</p><ol><li><p>指定了第二个参数</p><p>将deque扩充到n，后面新增元素初始化为val</p></li><li><p>未指定第二个参数</p><p>将deque扩充到n，后面新增元素正常初始化</p></li></ol><p>若n&lt;size时</p><p>将deque缩减到n，保留前n个元素，删除后续元素，此时第二个参数对函数执行没有影响</p><h2 id="assign函数"><a href="#assign函数" class="headerlink" title="assign函数"></a>assign函数</h2><p>assign函数会清除之前存在的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">range</span> (<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>&gt;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span> <span class="hljs-params">(InputIterator first, InputIterator last)</span></span>;<br><br><span class="hljs-built_in">fill</span> (<span class="hljs-number">2</span>)<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span> <span class="hljs-params">(size_type n, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><br><span class="hljs-function">initializer <span class="hljs-title">list</span> <span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">assign</span> <span class="hljs-params">(initializer_list&lt;value_type&gt; il)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>range版本</p><p>传入两个迭代器对象，deque的内容会由first-&gt;last的元素决定</p></li><li><p>fill版本</p><p>deque内容将会修改为n个val值</p></li><li><p>initializer list版本</p><p>deque内容是作为初始值设定项列表传递的值的副本，顺序相同。</p></li></ul><h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">single <span class="hljs-title">element</span> <span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><br><span class="hljs-built_in">fill</span> (<span class="hljs-number">2</span>)<br><br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, size_type n, <span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br><br><span class="hljs-built_in">range</span> (<span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIterator</span>&gt;<span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, InputIterator first, InputIterator last)</span></span>;<br><br><span class="hljs-built_in">move</span> (<span class="hljs-number">4</span>)<br><br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, value_type&amp;&amp; val)</span></span>;<br><br><span class="hljs-function">initializer <span class="hljs-title">list</span> <span class="hljs-params">(<span class="hljs-number">5</span>)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">iterator <span class="hljs-title">insert</span> <span class="hljs-params">(const_iterator position, initializer_list&lt;value_type&gt; il)</span></span>;<br></code></pre></td></tr></table></figure><p>上述所有函数的position参数均为一个迭代器，代表元素位置。返回值为第一个新插入元素的位置</p><ul><li><p>single element版本</p><p>在position之前插入元素val</p></li></ul><ul><li><p>fill版本</p><p>在position之前插入n个元素，元素值为val</p></li><li><p>range版本</p><p>在position前插入first-&gt;last中的元素</p></li></ul><ul><li><p>move版本</p><p>？？</p></li></ul><ul><li><p>initializer list 版本</p><p>在position之前插入il中的内容</p></li></ul><h2 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a>erase函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">erase</span> <span class="hljs-params">(const_iterator position )</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">erase</span> <span class="hljs-params">(const_iterator first, const_iterator last )</span></span>;<br></code></pre></td></tr></table></figure><p>删除单个元素，或者删除[first,last)元素</p><p>返回删除的最后一个元素的后一个位置，若是删除元素是最后一个位置，则返回容器末尾</p><h2 id="clear函数"><a href="#clear函数" class="headerlink" title="clear函数"></a>clear函数</h2><p>清除deque所有元素</p><h2 id="emplace函数-C11"><a href="#emplace函数-C11" class="headerlink" title="emplace函数(C11)"></a>emplace函数(C11)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;  <span class="hljs-function">iterator <span class="hljs-title">emplace</span> <span class="hljs-params">(const_iterator position, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>在position前插入元素，与insert的不同之处在于emplace是在指定位置直接构造元素，而不是先构造元素再复制或移动到容器中。这种方式可以减少不必要的拷贝或移动操作，提高效率。值得注意的是emplace一次只能插入一个元素，其后面插入args并不是说插入多个元素，而是args都是用来构造元素的。例如如果元素类型为pair</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">deque&lt;pair&lt;<span class="hljs-type">int</span>,string&gt; d;<br>d.emplace(d.begin(),9,&quot;alice&quot;);<br></code></pre></td></tr></table></figure><p>上述代码执行流程是将<code>9</code>和<code>alice</code>但做pair的构造函数的参数，构造出一个pair在插入到begin前</p><p>返回值为新元素位置。</p><h2 id="emplace-front和emplace-back函数"><a href="#emplace-front和emplace-back函数" class="headerlink" title="emplace_front和emplace_back函数"></a>emplace_front和emplace_back函数</h2><p>与push_front和push_back函数功能类似，只是与前面的emplace一样这两个函数是直接构造元素，而不是先构造元素再插入到容器中。等同于emplace(begin,…)和emplace(end,…)</p><h1 id="forward-list"><a href="#forward-list" class="headerlink" title="forward_list"></a>forward_list</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>forward_list可以理解为是stl实现的单链表</p><h2 id="emplace-after函数"><a href="#emplace-after函数" class="headerlink" title="emplace_after函数"></a>emplace_after函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;  <span class="hljs-function">iterator <span class="hljs-title">emplace_after</span> <span class="hljs-params">(const_iterator position, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>在某个位置之后构造并插入一个元素，注意与deque或者其他容器中的emplace函数区分，emplace函数是在某个位置之前。</p><p>不过返回值是一样的都是返回新插入的元素位置。</p><h2 id="erase-after函数"><a href="#erase-after函数" class="headerlink" title="erase_after函数"></a>erase_after函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">iterator <span class="hljs-title">erase_after</span> <span class="hljs-params">(const_iterator position)</span></span>;<br><span class="hljs-function">iterator <span class="hljs-title">erase_after</span> <span class="hljs-params">(const_iterator position, const_iterator last)</span></span>;<br></code></pre></td></tr></table></figure><p>删除某个位置后面的元素,或删除指定范围的元素不包两端(即position和last)</p><h2 id="before-begin函数"><a href="#before-begin函数" class="headerlink" title="before_begin函数"></a>before_begin函数</h2><p>它返回一个迭代器，指向列表的第一个元素之前的“位置”。这个可以理解为单链表中带头节点，主要是为了统一链表操作，不需要为第一个节点做特殊处理。由上面带after的函数也可以知道基本都是操作但前位置后一个元素，若没有before_begin函数返回指向列表的第一个元素之前的“位置“那么就需要对第一个元素做特殊处理。</p><h2 id="splice-after函数"><a href="#splice-after函数" class="headerlink" title="splice_after函数"></a>splice_after函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">entire <span class="hljs-title">list</span> <span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span> <span class="hljs-params">(const_iterator position, forward_list&amp; fwdlst)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span> <span class="hljs-params">(const_iterator position, forward_list&amp;&amp; fwdlst)</span></span>;<br><br><span class="hljs-function">single <span class="hljs-title">element</span> <span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span> <span class="hljs-params">(const_iterator position, forward_list&amp; fwdlst, const_iterator i)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span> <span class="hljs-params">(const_iterator position, forward_list&amp;&amp; fwdlst, const_iterator i)</span></span>;<br><br><span class="hljs-function">element <span class="hljs-title">range</span> <span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span> <span class="hljs-params">(const_iterator position, forward_list&amp; fwdlst,                   const_iterator first, const_iterator last)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splice_after</span> <span class="hljs-params">(const_iterator position, forward_list&amp;&amp; fwdlst,                   const_iterator first, const_iterator last)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>entire list版本</p><p>将整个fwlist拼接到position后面，同时fwlist会置为空。</p></li><li><p>single element版本</p><p>将fwlist中i位置后面的元素拼接到position后面，fwlist会失去i位置后面的元素</p></li><li><p>element range</p><p>将fwlist中位于first和last中的元素(不包括first和last)拼接到position后，fwlist将失去位于first和last中的元素(不包括first和last)</p></li></ul><h2 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span> <span class="hljs-params">(<span class="hljs-type">const</span> value_type&amp; val)</span></span>;<br></code></pre></td></tr></table></figure><p>移除forward_list中 <em><strong>所有</strong></em> 值为val的元素，注意与erase区分，erase传入的是迭代器，而remove传入的是值。</p><h2 id="remove-if函数"><a href="#remove-if函数" class="headerlink" title="remove_if函数"></a>remove_if函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Predicate</span>&gt;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_if</span> <span class="hljs-params">(Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure><p>移除所有使用pred后返回true的元素，pred是一个函数或者仿函数。例如remove函数使用remove_if表示就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">forward_list&lt;<span class="hljs-type">int</span>&gt; list;<br><span class="hljs-type">int</span> val=<span class="hljs-number">2</span>;<br>list.<span class="hljs-built_in">remove</span>(val);<br>list.<span class="hljs-built_in">remove_if</span>([&amp;val](<span class="hljs-type">int</span> value)&#123;<br>    <span class="hljs-keyword">return</span> value==val;<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述remove和remove_if功能是相同的</p><h2 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a>unique函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unique</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryPredicate</span>&gt;  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unique</span> <span class="hljs-params">(BinaryPredicate binary_pred)</span></span>;<br></code></pre></td></tr></table></figure><p>移除forward_list中连续相同的元素只保留第一个，也可以想remove_if一样自定义比较规则。</p><h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>list可以理解为是stl实现的双向链表</p><p>相较于forward_list，list因为是双向链表所以就不需要befor_begin函数了，且插入元素的函数也不在是insert_after,函数操作也不再都带after了，因为可以向前面插入，所以其插入方式也与其他容器差不多是向前插入。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++条款</title>
    <link href="/geez6572/2023/09/28/Effective%20C++/"/>
    <url>/geez6572/2023/09/28/Effective%20C++/</url>
    
    <content type="html"><![CDATA[<h1 id="1-传值尽量传引用-by-const"><a href="#1-传值尽量传引用-by-const" class="headerlink" title="1.传值尽量传引用(by const)"></a>1.传值尽量传引用(by const)</h1><p>关于函数传值尽量传应用刚开始我还不以为然，在我一次[leetcode][<a href="https://leetcode.cn/problems/number-of-boomerangs/]%E5%88%B7%E9%A2%98%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%88%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BD%93%E4%BC%9A%E5%88%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B0%BD%E9%87%8F%E4%BC%A0%E5%BC%95%E7%94%A8%E4%BA%86">https://leetcode.cn/problems/number-of-boomerangs/]刷题过程中我第一次体会到为什么要尽量传引用了</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; a, vector&lt;<span class="hljs-type">int</span>&gt; b)</span> </span>&#123;<br><br><span class="hljs-keyword">return</span> (a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) * (a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) + (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]) * (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br><br><span class="hljs-type">int</span> rs = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i) &#123;<br><br>unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; points.<span class="hljs-built_in">size</span>(); ++k) &#123;<br><br><span class="hljs-keyword">if</span> (k == i)<br><br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-type">int</span> dis = <span class="hljs-built_in">distance</span>(points[i], points[k]);<br><br><span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">count</span>(dis)) &#123;<br><br>map[dis]++;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>map[dis] = <span class="hljs-number">1</span>;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, v] : map) &#123;<br><br>rs+=v*(v<span class="hljs-number">-1</span>);<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">return</span> rs;<br><br>&#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是leetcode上一道算法题，这是我刚开始的写法，提交的时候花了1000多毫秒，于是我参考了官方题解发现官方题解跟我的思路是一样的，甚至代码的都一样，但运行只花了200多毫秒，我百思不得其解，后来才想明白于是改了下函数参数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distance</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; a, vector&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) * (a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>]) + (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]) * (a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><p>将原来的传递两个vector改为了vector的引用，运行后花费的时间就和官方题解差不多了。<br>事实上引用底层也是指针，大小固定的在这里传引用所需要的字节远小于传vector的字节，所以传引用快得多。<br>当然你也可能会抬杠说char类型就一个字节我传引用(引用我也不知道占多少字节，这里假设和指针一样)不是会增加字节吗？对于这个你要抬杠我也办法，因为确实如此。</p><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective STL</title>
    <link href="/geez6572/2023/09/28/EffectiveSTL/"/>
    <url>/geez6572/2023/09/28/EffectiveSTL/</url>
    
    <content type="html"><![CDATA[<h1 id="第一条：慎重选择容器类型"><a href="#第一条：慎重选择容器类型" class="headerlink" title="第一条：慎重选择容器类型"></a>第一条：慎重选择容器类型</h1><h2 id="连续内存容器"><a href="#连续内存容器" class="headerlink" title="连续内存容器"></a>连续内存容器</h2><p>把它的元素存放在一块或多块（动态分配的）内存中，每块内存中存有多个元素。标准的连续内存容器有vector、string和deque。</p><h2 id="基于节点的容器"><a href="#基于节点的容器" class="headerlink" title="基于节点的容器"></a>基于节点的容器</h2><p>在每一个（动态分配的）内存块中只存放一个元素。容器中元素的插入或删除只影响到指向节点的指针，而不影响节点本身的内容，所以当有插入或删除操作时，元素的值不需要移动。表示链表的容器，如list和slist,是基于节点的；所有标准的关联容器也是如此（通常的实现方式是平衡树）。</p><h2 id="选择容器时应考虑的问题"><a href="#选择容器时应考虑的问题" class="headerlink" title="选择容器时应考虑的问题"></a>选择容器时应考虑的问题</h2><ol><li><p>你是否需要在容器的任意位置插入新元素？</p><p>如果需要，就选择序列容器；关联容器是不行的。</p></li><li><p>你是否关心容器中的元素是如何排序的？</p><p>如果不关心，则哈希容器是一个可行的选择方案；否则，你要避免哈希容器。</p></li><li><p>你选择的容器必须是标准C++的一部分吗？</p><p>如果必须是，就排除了哈希容器、slist和rope。</p></li><li><p>你需要那种类型的迭代器？</p><p>如果它们必须是随机访问迭代器，则对容器的选择就被限定为vector、deque和string。或许你也可以考虑rope(有关rope的资料，见第50条)。如果要求使用双向迭代器，那么你必须避免sist(见第50条)以及哈希容器的一个常见实现（见第25条）。</p></li><li><p>当发生元素的插入或删除操作时，避免移动容器中原来的元素是否很重要？</p><p>如果是，就要避免连续内存的容器（见第5条）。</p></li><li><p>容器中数据的布局是否需要和C兼容？</p><p>如果需要兼容，就只能选择vector(见第16条)。</p></li><li><p>元素的查找速度是否是关键的考虑因素？</p><p>如果是，就要考虑哈希容器（见第25条）、排序的vector(见第23条)和标准关联容器-一或许这就是优先顺序。</p></li><li><p>如果容器内部使用了引用计数技术(reference counting),你是否介意？</p><p>如果是，就要避免使用string,因为许多string的实现都使用了引用计数。rope也需要避免，因为权威的rope实现是基于引用计数的（见第50条）。当然，你需要某种表示字符串的方法，这时你可以考虑vector<char>。</p></li><li><p>对插入和删除操作，你需要事务语义(transactional semantics)吗？也就是说，在插入和删除操作失败时，你需要回滚的能力吗？</p><p>如果需要，你就要使用基于节点的容器。如果对多个元素的插入操作（即针对一个区间的形式一见第5条）需要事<br>务语义，则你需要选择list,因为在标准容器中，只有list对多个元素的插入操作提<br>供了事务语义。对那些希望编写异常安全(exception-safe)代码的程序员，事务语义<br>显得尤为重要。</p></li><li><p>你需要使迭代器、指针和引用变为无效的次数最少吗？</p><p>如果是这样，就要使用基于节点的容器，因为对这类容器的插入和删除操作从来不会使迭代器、指针和引用变为无效（除非它们指向了一个你正在删除的元素）。而针对连续内存容器的插入和删除操作一般会使指向该容器的迭代器、指针和引用变为无效。</p></li><li><p>如果序列容器的迭代器是随机访问类型，而且只要没有删除操作发生，且插入操作只发生在容器的末尾，并且插入操作只发生在容器的末尾且不导致内存重新分配，则指向数据的指针和引用就不会变为无效，这样的容器是否对你有帮助？</p><p>这是非常特殊的情形，但如果你面对的情形正是如此，则deque是你所希望的容器。（有意思的是，当插入操作仅在容器末尾发生时，deque的迭代器有可能会变为无效。deque是惟一的、迭代器可能会变为无效而指针和引用不会变为无效的STL容器）。</p></li></ol><p>这里值得一提的是10，11的关于迭代器、指针和引用有效性问题。具体来说当使用vector和deque这些可以<code>扩充空间的连续内存容器</code>时，如果先前有一个迭代器、指针和引用指向容器中某个元素，而此时进行删除(size&lt;capacity&#x2F;2时重新分配内存)或插入(size&#x3D;&#x3D;capacity时重新分配内存)元素若容器可能会是容器重新分配内存，所以导致原先的迭代器、指针和引用会失效。而使用基于节点的容器就不会造成这种问题，因为它们内存分布是一块一个元素，插入元素不需要考虑扩充问题，直接修改内部指针即可，删除元素也是一样，可能造成迭代器、指针和引用失效的情况是迭代器、指针和引用指向的就是要删除的元素。</p><h1 id="第二条-不要试图编写独立于容器类型的代码"><a href="#第二条-不要试图编写独立于容器类型的代码" class="headerlink" title="第二条 不要试图编写独立于容器类型的代码"></a>第二条 不要试图编写独立于容器类型的代码</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中的IO操作</title>
    <link href="/geez6572/2023/09/28/Java_IO/"/>
    <url>/geez6572/2023/09/28/Java_IO/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h1><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>我们通常说的JavaIO一般就是指BIO(Block IO)也就是阻塞IO。</p><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入&#x2F;输出流"></a>输入&#x2F;输出流</h3><p>在java的bio中由InputStream和OutputStream两个抽象基类构成了<code>面向字节序列</code>的输入&#x2F;输出类的层次结构，由于面向字节的流并不适合处理Unicode字符所以又由Reader和Writer两个抽象基类构成了<code>面向字符</code>的输入&#x2F;输出类的层次结构，以下是BIO的类层次。</p><p><img src="https://s3.bmp.ovh/imgs/2024/11/29/05bc917b108a42e0.png"></p><p>Java中BIO中所有流都带有缓冲区，默认为行缓冲，</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO是JDK1.8引入的新的用于IO操作的API，全称是New IO意为新IO，但实际上叫NoBlock IO非阻塞IO更加合适。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode算题笔记</title>
    <link href="/geez6572/2023/09/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <url>/geez6572/2023/09/28/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="最后一块石头重量"><a href="#最后一块石头重量" class="headerlink" title="最后一块石头重量"></a>最后一块石头重量</h2><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/">leetcode链接</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题可以联系到背包问题，因为本题实际上可转化为求解背包容量为所有石头重量之和一半时所能容纳的最大石头重量。<br>递归五步曲：</p><ol><li>确定dp数组及其含义<br> dp[i]表示当背包容量为i时所能容纳石头的最大重量</li><li>确定递推公式<br> dp[k]&#x3D;max(dp[k],dp[k-stones[i]]+stones[i])</li><li>dp数组初始化<br> dp数组容量自然是所有石头重量之和的一半+1，初始化应全为0。</li><li>确定遍历顺序<br> 首先考虑放第一块石头，背包容量为0-k所能容纳的最大重量，<br> 然后在考虑前两块石头，背包容量为0-k所能容纳的最大重量，<br> 依此类推。可知应先遍历石头总数再遍历容量。代码下 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = target; k &gt;= stones[i]; k--) &#123;<br>  dp[k] = <span class="hljs-built_in">max</span>(dp[k], dp[k - stones[i]] + stones[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>举例推导dp数组</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lastStoneWeightII</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;stones)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (stones.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> stones[<span class="hljs-number">0</span>];<br>  <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> stone : stones) &#123;<br>    sum += stone;<br>  &#125;<br>  <span class="hljs-type">int</span> target = sum / <span class="hljs-number">2</span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; stones.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = target; k &gt;= stones[i]; k--) &#123;<br>      dp[k] = <span class="hljs-built_in">max</span>(dp[k], dp[k - stones[i]] + stones[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> sum - (dp[target] * <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p><a href="https://leetcode.cn/problems/target-sum/">leetcode链接</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题可能很难想到使用01背包解决问题，更多可能会想到排列组合的回溯算法，也确实能够解决问题不过复杂度太高了。实际上本题也能使用01背包解决问题，假设加法总和为x，那么减法总和就是sum-x,目标值target&#x3D;x-(sum-x);从而得到x&#x3D;(sum+target)&#x2F;2;因此我们将加减法两种情况归纳到只有加法的情况而不用考虑减法，即背包容量为x时有几种方法装满背包。<br>递归五部曲：</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp">```<br><br>## 一和零<br>[leetcode链接](https:<span class="hljs-comment">//leetcode.cn/problems/ones-and-zeroes/)</span><br><br>### 思路<br>本题也是一个典型<span class="hljs-number">01</span>背包问题，不过本题的不同点在与背包有两个维度，即<span class="hljs-number">0</span>的个数和<span class="hljs-number">1</span>的个数。依次遍历字符串每遍历一个字符串计算出其中含有的<span class="hljs-number">0</span>的个数和<span class="hljs-number">1</span>的个数，然后取放入和不放入的最大值即可。<br>动态规划五部曲：<br><span class="hljs-number">1.</span> 确定dp数组及其含义<br>dp\[i]\[k]表示当背包中可以容纳i各<span class="hljs-number">0</span>和k个<span class="hljs-number">0</span>时，最大子集大小为dp\[i]\[k]<br><span class="hljs-number">2.</span> 确定递推公式<br>dp\[i]\[k]可以由前一个strs中字符串中推导出来，即若是不放当前字符串则起子集大小为dp\[i]\[k]<br>若是放入则起子集大小应为dp\[i-zero]\[k-one]<span class="hljs-number">+1</span>,其中zero为当前字符串含<span class="hljs-number">0</span>的个数，one为当前字符串含<span class="hljs-number">1</span>的个数，加一是因为当前字符串已经加入子集当中。<br><span class="hljs-number">3.</span> dp数组初始化<br>初始化为<span class="hljs-number">0</span>即可<br><span class="hljs-number">4.</span> 确定遍历顺序<br>按<span class="hljs-number">01</span>背包来说应该先遍历物品，后遍历重量。在本题中应该是先遍历字符串(物品)，因为重量为<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的个数所以我们应该先知道<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的个数，所以然后应该遍历字符串以确定<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的个数，最后依据<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的个数(重量)遍历即可。<br><br>### 代码实现<br>```cpp<br><span class="hljs-type">int</span> <span class="hljs-built_in">findMaxForm</span>(vector&lt;string&gt; &amp;strs, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n) &#123;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(m + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>  <span class="hljs-comment">// 遍历字符串数组(物品)</span><br>  <span class="hljs-keyword">for</span> (string str : strs) &#123;<br>    <span class="hljs-comment">// 确定0和1的个数(重量)</span><br>    <span class="hljs-type">int</span> zero = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> one = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>      <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;0&#x27;</span>)<br>        ++zero;<br>      <span class="hljs-keyword">else</span><br>        ++one;<br>    &#125;<br>    <span class="hljs-comment">// 根据0和1的个数(重量)遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m; i &gt;= zero; --i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = n; k &gt;= one; --k) &#123;<br>        dp[i][k] = <span class="hljs-built_in">max</span>(dp[i][k], dp[i - zero][k - one] + <span class="hljs-number">1</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p><a href="https://leetcode.cn/problems/house-robber/description/">leetcode链接</a></p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><a href="https://leetcode.cn/problems/target-sum/">leetcode链接</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">```<br><br><br># 分治算法<br>## 颠倒二进制位<br>[leetcode链接](https:<span class="hljs-comment">//leetcode.cn/problems/reverse-bits/description/)</span><br><br>### 思路<span class="hljs-number">1</span><br>可以采用逐位颠倒方式,采用该方式需要注意的是即使二进制前面有<span class="hljs-number">0</span>也要颠倒，所以采用以下方式是错误的,此时若不算前面的<span class="hljs-number">0</span>的话是对的否则是错的，例如<br><span class="hljs-number">0011</span>,使用该代码颠倒，因为会忽略前面两个<span class="hljs-number">0</span>所以颠倒结果为<span class="hljs-number">11</span><br>而事实上我们需要的结果是<span class="hljs-number">1100</span><br>```cpp<br><span class="hljs-type">uint32_t</span> <span class="hljs-built_in">reverseBits</span>(<span class="hljs-type">uint32_t</span> n) &#123;<br><span class="hljs-type">uint32_t</span> rs = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(n)&#123;<br>rs=(rs&lt;&lt;<span class="hljs-number">1</span>)+(n&amp;<span class="hljs-number">1</span>);<br>n=n&gt;&gt;<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> rs;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br><span class="hljs-type">uint32_t</span> rs = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> &amp;&amp; n; i++) &#123;<br>rs = rs | ((n &amp; <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-number">31</span> - i));<br>n=n&gt;&gt;<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> rs;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RPC框架</title>
    <link href="/geez6572/2023/09/28/RPC%E6%A1%86%E6%9E%B6/"/>
    <url>/geez6572/2023/09/28/RPC%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC框架"><a href="#RPC框架" class="headerlink" title="RPC框架"></a>RPC框架</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="网络传输层面"><a href="#网络传输层面" class="headerlink" title="网络传输层面"></a><strong>网络传输层面</strong></h3><p><strong>1.netty传输位于网络结构模型中的哪一层？</strong></p><ol><li>传输层</li><li>Netty支持TCP和UDP等传输层协议，通过对这些协议的封装和抽象，Netty能够处理传输层的数据传输任务，如建立连接、数据传输和连接关闭等。</li><li>Netty的EventLoop和EventLoopGroup等组件基于Java NIO的多路复用器（Selector），实现了高效的IO事件处理机制，这在一定程度上与传输层的数据传输和事件处理机制相呼应。</li><li>应用层</li><li>Netty提供了丰富的协议支持，如HTTP、WebSocket、SSL、Protobuf等，这些协议主要工作在应用层。Netty通过编解码器等组件，能够方便地在应用层对数据进行编解码，从而实现与应用层协议的交互。</li><li>Netty的ChannelPipeline和ChannelHandler等组件构成了一个灵活的事件处理链，允许开发者在应用层自定义各种事件处理逻辑，如身份验证、消息加密、业务逻辑处理等。</li></ol><p><strong>2.讲一讲netty在你项目中的作用和执行流程？</strong></p><p><strong>作用</strong>：引用高性能网络框架netty，实现了高效的信息传输；抽象了Java NIO底层的复杂性，提供了简单易用的API，简化了网络编程；提供各种组件方便网络数据的处理</p><p><strong>执行流程：</strong></p><ol><li>客户端发起请求</li><li>客户端根据服务地址通过Netty客户端API创建一个客户端Channel，并连接到服务端的指定端口。</li><li>客户端将RPC调用信息（如方法名、参数等）封装成请求消息，并通过Netty的编码器（Encoder）将请求消息序列化成字节流。</li><li>客户端将序列化后的字节流通过网络发送给服务端。</li><li>服务端接收请求并处理</li><li>服务端通过Netty服务端API监听指定端口，等待客户端的连接请求。</li><li>当接收到客户端的连接请求时，服务端通过Netty的解码器（Decoder）将接收到的字节流反序列化成请求消息。</li><li>服务端根据请求消息中的方法名和参数等信息，通过反射调用本地服务实现，并将执行结果封装成响应消息。</li><li>服务端通过Netty的编码器将响应消息序列化成字节流，并通过网络发送给客户端。</li><li>客户端接收响应</li><li>客户端接收到服务端的响应字节流后，通过Netty的解码器将字节流反序列化成响应消息。</li><li>客户端根据响应消息中的结果信息，进行相应的业务处理。</li></ol><p><strong>3.为什么会出现沾包问题？如何解决的？</strong></p><p>​netty默认底层通过TCP 进行传输，TCP<strong>是面向流的协议</strong>，接收方在接收到数据时无法直接得知一条消息的具体字节数，不知道数据的界限。由于TCP的流量控制机制，发生沾包或拆包，会导致接收的一个包可能会有多条消息或者不足一条消息，从而会出现接收方少读或者多读导致消息不能读完全的情况发生</p><p>​在发送消息时，先告诉接收方消息的长度，让接收方读取指定长度的字节，就能避免这个问题；项目中通过自定义的消息传输协议来实现对沾包问题的解决。</p><p><strong>4.你听过过哪些序列化方式？觉得哪种数据序列化方式最好？</strong></p><p><strong>Java对象序列化</strong></p><p><strong>优点</strong>：</p><p>​<strong>兼容性高</strong>，可以方便地在Java应用内部进行对象持久化和传输。</p><p><strong>缺点</strong>：</p><p>​序列化后的数据较大，速度相对较慢；不支持跨语言，仅适用于Java环境。</p><p><strong>JSON</strong></p><p><strong>优点</strong>：</p><p>​<strong>可读性好</strong>：JSON数据以文本形式存在，易于人类阅读和编写，方便调试和日志记录。<strong>跨语言支持</strong>：几乎所有主流编程语言都提供了JSON的解析和生成库，使得JSON成为跨语言数据交换的理想选择。</p><p><strong>缺点</strong>：</p><p>​<strong>效率较低</strong>：相对于二进制序列化格式（如Protobuf和Hessian），JSON的解析和序列化效率较低，特别是在处理大型数据结构时。</p><p><strong>Protobuf</strong></p><p><strong>优点</strong>：</p><p>​<strong>高效</strong>：Protobuf使用二进制编码，相比JSON和XML等文本格式，序列化后的数据更小，解析速度更快。</p><p>​<strong>向前向后兼容</strong>：Protobuf支持数据结构的向前和向后兼容，可以在不破坏旧程序的情况下更新数据结构。</p><p><strong>缺点</strong>：</p><p>​<strong>可读性差</strong>：Protobuf序列化后的数据是二进制格式，不易于人类直接阅读。</p><p>​<strong>需要定义文件</strong>：使用Protobuf需要先定义数据结构（.proto文件），然后生成序列化&#x2F;反序列化的代码。</p><p><strong>Hessian</strong></p><p><strong>优点</strong>：</p><p>​<strong>高效</strong>：Hessian是一个轻量级的remoting on http工具，提供了RMI的功能，采用二进制RPC协议，序列化效率高。</p><p>​<strong>简单易用</strong>：Hessian协议简单，实现起来相对容易。</p><p><strong>缺点</strong>：</p><p>​<strong>可读性差</strong>：Hessian序列化后的数据也是二进制格式，不易于人类直接阅读。</p><p>​<strong>安全性不足</strong>：Hessian传输没有加密处理，对于安全性要求高的应用可能不适用。</p><p>​<strong>生态系统支持</strong>：相对于JSON和Protobuf，Hessian的生态系统支持可能较少。</p><p>对于Rpc框架来说，使用Protobuf或者Hessian这种序列化后为二进制格式的数据，在消息传输上相比于Json，会更加高效</p><p><strong>5.netty的常见八股</strong></p><p>BIO,NIO；netty的构成，组件，执行流程</p><p><a href="https://blog.csdn.net/qq_35190492/article/details/113174359?spm=1001.2014.3001.5506">【硬核】肝了一月的Netty知识点-CSDN博客</a></p><h3 id="注册中心层面"><a href="#注册中心层面" class="headerlink" title="注册中心层面"></a><strong>注册中心层面</strong></h3><p><strong>1.zookeeper在项目中的角色？你为什么使用zookeeper</strong></p><ol><li>zookeeper作为项目的注册中心，实现着服务注册，服务发现和维护服务状态的功能；</li><li>zookeeper具有高可用性，一致性，有着丰富的api，应用广阔，很多大数据框架都有他的身影。</li></ol><p><strong>2.注册中心的意义？</strong></p><p>①服务注册与发现：注册中心实现了微服务架构中各个微服务的服务注册与发现，这是其最基础也是最重要的功能。通过注册中心，各个微服务可以将自己的地址信息（如IP地址、端口号等）注册到中心，同时也能够从中发现其他微服务的地址信息。</p><p>②动态性：在微服务架构中，服务的数量和位置可能会频繁变化。注册中心能够动态地处理这些变化，确保服务消费者能够实时获取到最新的服务提供者信息。</p><p>③增强微服务之间的去中心化在单体项目中，模块之间的依赖关系是通过内部的直接引用来实现的。而在微服务架构中，注册中心的存在使得微服务之间的依赖关系不再是直接的函数引用，而是通过注册中心来间接调用。这种方式增强了微服务之间的去中心化，提高了系统的灵活性和可扩展性。</p><p>④提升系统的可用性和容错性注册中心通常具有高可用性的设计，能够确保在部分节点故障时仍然能够正常工作。这使得整个微服务架构在面临故障时能够更加稳定地运行。</p><p><strong>3.zookeeper的常见八股</strong></p><p>这里了解zookeeper的结构 和特点即可，面试一般不会问的太深入</p><p><a href="https://blog.csdn.net/xiaojiejie_baby/article/details/136485414?ops_request_misc=&request_id=&biz_id=102&utm_term=zookeeper%E9%9D%A2%E8%AF%95%E9%A2%98&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-136485414.nonecase&spm=1018.2226.3001.4187">https://blog.csdn.net/xiaojiejie_baby&#x2F;article&#x2F;details&#x2F;136485414?ops_request_misc&#x3D;&amp;request_id&#x3D;&amp;biz_id&#x3D;102&amp;utm_term&#x3D;zookeeper%E9%9D%A2%E8%AF%95%E9%A2%98&amp;utm_medium&#x3D;distribute.pc_search_result.none-task-blog-2<del>all</del>sobaiduweb~default-2-136485414.nonecase&amp;spm&#x3D;1018.2226.3001.4187</a></p><h3 id="算法层面"><a href="#算法层面" class="headerlink" title="算法层面"></a><strong>算法层面</strong></h3><p><strong>1.三种负载均衡算法的比较？</strong></p><p>轮询法（Round Robin）</p><ol><li><strong>原理</strong>：轮询法将所有请求按顺序轮流分配给后端服务器，依次循环。</li><li><strong>优点</strong></li><li>简单易实现。</li><li>无状态，不保存任何信息，因此实现成本低。</li><li><strong>缺点</strong></li><li>当后端服务器性能差异大时，无法根据服务器的负载情况进行动态调整，可能导致某些服务器负载过大或过小。</li><li>如果服务器配置不一样，不适合使用轮询法。</li></ol><p>随机法（Random）</p><ol><li><strong>原理</strong>：随机法将请求随机分配到各个服务器。</li><li><strong>优点</strong></li><li>分配较为均匀，避免了轮询法可能出现的连续请求分配给同一台服务器的问题。</li><li>使用简单，不需要复杂的配置。</li><li><strong>缺点</strong></li><li>随机性可能导致某些服务器被频繁访问，而另一些服务器则相对较少，这取决于随机数的生成情况。</li><li>如果服务器配置不同，随机法可能导致负载不均衡，影响整体性能。</li></ol><p>一致性哈希法（Consistent Hashing）</p><ol><li><strong>原理</strong>：一致性哈希法将输入（如客户端IP地址）通过哈希函数映射到一个固定大小的环形空间（哈希环）上，每个服务器也映射到这个哈希环上。客户端的请求会根据哈希值在哈希环上顺时针查找，遇到的第一个服务器就是该请求的目标服务器。</li><li><strong>优点</strong></li><li>当服务器数量发生变化时，只有少数键需要被重新映射到新的服务器上，这大大减少了缓存失效的数量，提高了系统的可用性。</li><li>具有良好的可扩展性，可以动态地添加或删除服务器。</li><li><strong>缺点</strong></li><li>在哈希环偏斜的情况下，大部分的缓存对象很有可能会缓存到一台服务器上，导致缓存分布极度不均匀。</li><li>实现较为复杂，需要引入虚拟节点等技术来解决哈希偏斜问题。</li></ol><p><strong>2.讲一讲一致性哈希算法？</strong></p><p>一致性哈希算法的原理和优化，可以参考文章</p><p><a href="https://blog.csdn.net/zhanglu0223/article/details/100579254?spm=1001.2014.3001.5506">https://blog.csdn.net/zhanglu0223/article/details/100579254?spm=1001.2014.3001.5506</a></p><p><strong>3.限流算法有哪些？</strong></p><p>常见的限流算法有4种：计数器法，滑动窗口算法，漏桶算法和令牌桶算法</p><p>对于上面4种算法的详细介绍和优缺点比较可以参考</p><p><a href="https://javaguide.cn/high-availability/limit-request.html">https://javaguide.cn/high-availability/limit-request.html</a></p><p><strong>4.令牌桶算法如何实现的？</strong></p><p><strong>令牌桶算法简介</strong>令牌桶是指一个限流容器，容器有最大容量，每秒或每100ms产生一个令牌（具体取决于机器每秒处理的请求数），当容量中令牌数量达到最大容量时，令牌数量也不会改变了，只有当有请求过来时，使得令牌数量减少（只有获取到令牌的请求才会执行业务逻辑），才会不断生成令牌</p><p>**令牌桶算法限流范围：**假设令牌桶最大容量为n，每秒产生r个令牌</p><p>平均速率：则随着时间推延，处理请求的平均速率越来越趋近于每秒处理r个请求，说明令牌桶算法可以控制平均速率</p><p>瞬时速率：如果在一瞬间有很多请求进来，此时来不及产生令牌，则在一瞬间最多只有n个请求能获取到令牌执行业务逻辑，所以令牌桶算法也可以控制瞬时速率</p><h3 id="各种场景题"><a href="#各种场景题" class="headerlink" title="各种场景题"></a><strong>各种场景题</strong></h3><p>这方面一般是围绕着降级熔断重试 等等问题来回答，主要考察项目是否是自己做出来的，是否有对项目有过思考</p><p><strong>1.本地缓存怎么做的？能保证缓存和服务的一致性吗？</strong></p><p>在客户端设计一个缓存层，每次调用服务时从缓存层中获取地址，避免直接调用注册中心，优化速度和资源</p><p>可以。这里使用了zookeeper的监听机制，在服务节点上注册Watcher，当注册中心的服务地址发生改动时，Watcher会异步通知客户端的缓存层修改对应的地址，从而实现两者的一致性</p><p><strong>2.某个服务多个节点承压能力不一，怎么办？</strong></p><p>​前面学习过一致性哈希算法 就会知道，在一致性哈希算法中，使用虚拟节点对真实节点进行映射，并且能通过设置虚拟节点的个数 来控制该节点接收到请求的概率。</p><p>​所以在服务器负载能力不一致的情况下，我们可以在服务端将服务器的负载能力写入到注册中心中，客户端在进行负载均衡时会在注册中心中获取各服务器的能力，并设置对应的虚拟节点的数量，来控制流量的分发。</p><p>​这里可以拓展一下自适应负载均衡的实现</p><p><strong>3.网络抖动导致某个节点被下线了，过一会网络好了，考虑过这个问题吗？</strong></p><p>当调用端发起的请求失败时，RPC 框架自身可以进行重试，再重新发送请求，通过这种方式保证系统的容错率；</p><p>项目使用Google Guava这款性能强大且轻量的框架来实现失败重试的功能；</p><p><strong>4.每个服务都进行重试吗？</strong></p><p>如果这个服务业务逻辑不是幂等的，比如插入数据操作，那触发重试的话会不会引发问题呢？</p><p>会的。</p><p>在使用 RPC 框架的时候，要确保被调用的服务的业务逻辑是幂等的，这样才能考虑根据事件情况开启 RPC 框架的异常重试功能</p><p>所以，我们可以<strong>设置一个白名单</strong>，服务端在注册节点时，将幂等性的服务注册在白名单中，客户端在请求服务前，先去白名单中查看该服务是否为幂等服务，如果是的话使用重试框架进行调用</p><p>白名单存放在zookeeper中（充当配置中心的角色）</p><p><strong>5.如果下游有一个服务的所有服务器都宕机了，该怎么做避免失败请求的大量堆积</strong></p><p>​项目在客户端调用的链路头部设置了熔断器，当检测到失败次数超过阈值时，熔断器会变为关闭状态，阻止后续的请求；在一定时间后，熔断器变为半开状态，并根据之后请求的成功情况来决定是否阻止或放行请求</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Reacto模型</title>
    <link href="/geez6572/2023/09/28/Reacto%E6%A8%A1%E5%9E%8B/"/>
    <url>/geez6572/2023/09/28/Reacto%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Reacto模型"><a href="#Reacto模型" class="headerlink" title="Reacto模型"></a>Reacto模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>reactor模型是一种并发模型，不是一种技术，这跟设计模式有点像，你的代码这样写我管者端代码较xx设计模式，reactor模型也是一样的，甚至你就可一把它理解为一种设计模式。</p><h2 id="reactor演进"><a href="#reactor演进" class="headerlink" title="reactor演进"></a>reactor演进</h2><p>要明白reactor模型的优点，就要明白reactor模型是如何产生，解决了传统并发模型的什么难点。</p><h3 id="阻塞模式-单线程"><a href="#阻塞模式-单线程" class="headerlink" title="阻塞模式(单线程)"></a>阻塞模式(单线程)</h3><p>是最老的一种模式，通过不断的监听端口来查看是否有新的连接，如果有则调用处理函数，示例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket serverSocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>...<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 不断监听端口，接受连接</span><br>    socket =serverSocket.accept();<br>    <span class="hljs-comment">// 得到连接后进行业务处理</span><br>    handle(socket);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法最大的问题在于如果前一个网络连接未处理完，后面的新连接就无法被服务端接收。这里假设有10个用户连接，第一个到的用户处理时间需要花费1分钟，而在接收了第一个连接后，会阻塞在handle函数1分钟，而这期间其他的9个连接均无法正确接收。这缺点十分明显仅仅因为任意一个请求的处理时间稍长，后面的请求就都要等待。</p><h3 id="阻塞模式-多线程"><a href="#阻塞模式-多线程" class="headerlink" title="阻塞模式(多线程)"></a>阻塞模式(多线程)</h3><p>既然前一种方法会因为一个连接的业务处理而耽误其他连接，那么最直观的思考是能不能将处理业务交给线程，这样我们就能继续监听和接收新连接了。实例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket serverSocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>...<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 不断监听端口，接受连接</span><br>    socket =serverSocket.accept();<br>    <span class="hljs-comment">// 得到连接后,创建一个线程进行业务处理</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handle</span>(socket)).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法极大的改善前一种方法的缺点，但仍然存在问题，就是在面对大量的连接是会耗费大量的线程资源，对线程资源要求极高，如果线程数量过多会导致系统崩溃。而且创建和销毁线程都需要代价。</p><h3 id="阻塞模式-线程池"><a href="#阻塞模式-线程池" class="headerlink" title="阻塞模式(线程池)"></a>阻塞模式(线程池)</h3><p>要解决上一个方法的缺点我们可以使用<code>资源复用</code>的方式。也就是不用再为每个连接创建线程，而是创建一个「线程池」，将连接分配给线程，然后一个线程可以处理多个连接的业务。这样因为线程池中的线程是固定的，就解决了上一个方法的大量的连接是会耗费大量的线程资源的问题。而且线程池中线程只需创建一次，所以也解决了线程创建和销毁线程都需要代价的问题。实例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerSocket serverSocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br>...<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 不断监听端口，接受连接</span><br>    socket =serverSocket.accept();<br>    <span class="hljs-comment">// 得到连接后,从线程池中获取一个线程进行业务处理</span><br>    threadPool.submit(()-&gt;&#123;<br>        handle(socket);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方法缺点就是在处理长连接线程利用率也不是很高因为线程在长时间处于阻塞状态。举个例子假设我们目前连接已经建立某个处理线程，那么线程的处理流程无非就是<code>等待请求-&gt;读取请求-&gt;业务处理-&gt;响应请求</code>想象一下如果客户建立连接后长时间不发请求但就是不关闭连接(即客户的请求时间间隔大)，那么这个线程将一直阻塞在<code>等待请求</code>这一步中而不干其他任何事情。这就造成了线程资源利用率低下，因为我们本来可以用户不发请求时去干别的事的。因此这种方法适用于短连接，在长连接中弊端会很明显。</p><h3 id="非阻塞模式-IO多路复用-线程池"><a href="#非阻塞模式-IO多路复用-线程池" class="headerlink" title="非阻塞模式+IO多路复用(线程池)"></a>非阻塞模式+IO多路复用(线程池)</h3><p>要解决上一个方法的缺点最简单的就是使用非阻塞模式，我们可以不断轮询调用read操作来判断是否有数据，这种方式虽然该能够解决阻塞的问题，但是解决的方式比较粗暴，因为轮询是要消耗 CPU 的，而且随着一个 线程处理的连接越多，轮询的效率就会越低。</p><p>可以采用IO多路复用技术，该技术原理是使用一个线程监听多个连接，当某个连接有事件发生时，我们在从线程池中取一个线程去处理该事件，处理完后线程回到线程池，这样我们线程的执行流程就变成了<code>读取请求-&gt;业务处理-&gt;响应请求</code>,而上一个方法中的<code>等待请求</code>使用IO多路复用处理。</p><p>而这种方法其实就是reactor模式的雏形。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/geez6572/2023/09/28/Redis/"/>
    <url>/geez6572/2023/09/28/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="redis基本使用"><a href="#redis基本使用" class="headerlink" title="redis基本使用"></a>redis基本使用</h2><h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><p>Redis使用了单线程架构和IO多路复用模型来实现高性能的<code>内存</code>数据库服务。这里单线程是指redis在执行命令时采用的时单线程，所以redis不会出现并发问题；而在处理IO是采用的是IO多路复用模型实现。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>STL源码剖析</title>
    <link href="/geez6572/2023/09/28/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/geez6572/2023/09/28/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-STL概述"><a href="#第一章-STL概述" class="headerlink" title="第一章 STL概述"></a>第一章 STL概述</h1><h2 id="1-1-STL六大组件与运用"><a href="#1-1-STL六大组件与运用" class="headerlink" title="1.1 STL六大组件与运用"></a>1.1 STL六大组件与运用</h2><ol><li>容器：各种数据结构，vector,list，deque,set,map</li><li>算法：提供search,sort，copy等算法</li><li>迭代器：扮演容器和算法之间的胶合剂，及泛型指针。</li><li>防函数：行为类似函数，可以作为算法的某种策略</li><li>配接器：一种用来修饰容器，防函数，迭代器接口的东西。</li><li>配置器：负责空间配置与管理</li></ol><h2 id="STL中为什么有的容器实现了sort函数（list-而有的没有实现sort而是使用algorithm库中的sort函数"><a href="#STL中为什么有的容器实现了sort函数（list-而有的没有实现sort而是使用algorithm库中的sort函数" class="headerlink" title="STL中为什么有的容器实现了sort函数（list),而有的没有实现sort而是使用algorithm库中的sort函数"></a>STL中为什么有的容器实现了sort函数（list),而有的没有实现sort而是使用algorithm库中的sort函数</h2><p>algorithm中sort函数上面的模板有说明sort函数的参数中的迭代器必须是可以随机存取的即类似数组一样可以用下标访问。</p><p>而list是链表很明显不具有随机存取性，所以只能自己实现sort函数</p><h1 id="第二章-空间适配器-allocator"><a href="#第二章-空间适配器-allocator" class="headerlink" title="第二章 空间适配器(allocator)"></a>第二章 空间适配器(allocator)</h1><h2 id="2-1-空间适配器标准接口"><a href="#2-1-空间适配器标准接口" class="headerlink" title="2.1 空间适配器标准接口"></a>2.1 空间适配器标准接口</h2><p>根据STL规范，空间适配器标准接口如下：</p><blockquote><p>&#x2F;&#x2F;类型定义</p><p>allocator::value_type</p><p>allocator::pointer</p><p>allocator::const_pointer</p><p>allocator::reference</p><p>allocator::const_reference</p><p>allocator::size_type</p><p>allocator::difference_type</p><p>&#x2F;&#x2F;函数</p><p>allocator::rebind()</p><p>allocator::allocator()</p><p>allocator::allocator(const allocator&amp;)</p></blockquote><h3 id="new和operator-new，delete和operator-delete-的区别"><a href="#new和operator-new，delete和operator-delete-的区别" class="headerlink" title="new和operator new，delete和operator delete 的区别"></a><em>new</em>和<em>operator new</em>，<em>delete</em>和<em>operator delete</em> 的区别</h3><p><code>operator new</code>是一个函数，只负责分配内存，其底层使用C语言的malloc实现</p><p><code>new</code>是一个操作符，它不仅负责分配内存，还负责调用构造函数来初始化对象，内含两段操作(1)调用<code>operator new</code>分配内存 (2)调用对象构造函数初始化对象</p><p><code>operator delete</code>是一个函数，只负责释放内存，其底层使用C语言free实现</p><p><code>delete</code>是一个操作符，它不仅负责释放内存，还负责调用析构函数，内含两段操作(1)调用对象的析构函数 (2)调用<code>operator delete</code>释放内存</p><h1 id="第三章-迭代器"><a href="#第三章-迭代器" class="headerlink" title="第三章 迭代器"></a>第三章 迭代器</h1><h2 id="3-1-迭代器设计"><a href="#3-1-迭代器设计" class="headerlink" title="3.1 迭代器设计"></a>3.1 迭代器设计</h2><p>迭代器是STL的精髓所在，在STL中容器和算法是彼此分开独立设计的，而要想让容器使用算法中的函数则必须通过迭代器作为桥梁来使用，比如常见算法中sort函数，find函数等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vec=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-comment">//vector中的begin和end函数均会返回一个迭代器</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator begin=vec.<span class="hljs-built_in">begin</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator end=vec.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-comment">//调用algorithm库中的sort函数，需要传入两个迭代器，分别为容器开始的迭代器</span><br>    <span class="hljs-comment">//和容器结束的迭代器</span><br>    <span class="hljs-built_in">sort</span>(begin,end);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-迭代器是一种智能指针"><a href="#3-2-迭代器是一种智能指针" class="headerlink" title="3.2 迭代器是一种智能指针"></a>3.2 迭代器是一种智能指针</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shell编程</title>
    <link href="/geez6572/2023/09/28/Shell%E7%BC%96%E7%A8%8B/"/>
    <url>/geez6572/2023/09/28/Shell%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="shell编程基础"><a href="#shell编程基础" class="headerlink" title="shell编程基础"></a>shell编程基础</h1><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>变量使用要通常需要加<code>$</code>才能使用。关于变量什么时候需要加<code>$</code>什么时候不需要，一般来说如果是使用变量这需要加<code>$</code>,如果是操作变量则不需要，这里只是说大部分情况下都是这样，也有小部分情况例外。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">value=&quot;aa&quot;  // 这里我们是令value等于“aa”，在这里是对变量赋值，属于操作变量，故value无需加$<br>echo $value // 这里我们是输出value的值，属于使用value所以需要加$<br></code></pre></td></tr></table></figure><h2 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a>命令替换</h2><p>在shell中允许提取命令的输出并赋值给变量。可以使用<code>$(命令)</code>和`命令`两种方式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">date<br>vdate1=`date`<br>vdate2=$(date)<br>echo $vdate1<br>echo $vdate2<br></code></pre></td></tr></table></figure><h2 id="重定向输入输出"><a href="#重定向输入输出" class="headerlink" title="重定向输入输出"></a>重定向输入输出</h2><h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h3><p>使用<code>&gt;</code>来重定向输出。最常见是输出重定向到文件，若文件不存在则会通过默认的umask设置创建一个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">date &gt; test1<br>cat test1<br></code></pre></td></tr></table></figure><p>使用<code>&gt;&gt;</code>来重定向输出，但与<code>&gt;</code>不同的是<code>&gt;&gt;</code>是追加，而<code>&gt;</code>是覆盖。</p><h3 id="重定向输入"><a href="#重定向输入" class="headerlink" title="重定向输入"></a>重定向输入</h3><p>使用<code>&lt;</code>重定向输入。最常见的是输入重定向为文件，也就是从文件中读取输入。这个就要求文件必须存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wc &lt; test1<br></code></pre></td></tr></table></figure><p>重定向中的<code>&lt;&lt;</code>被称作内联输出重定向，这种方法无须使用文件进行重定向，只需要在命令行中指定即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">command &lt;&lt; mark<br></code></pre></td></tr></table></figure><p>运行命令后会进入待输入的界面，只有当输入为mark是才会结束，并执行命令。</p><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h3><p>expr允许处理数学表达式，expr能识别的常见数学操作和少数字符串操作如下。</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240610212957630.png" alt="image-20240610212957630"></p><p>使用方法是在expr命令后面接上上图中的操作符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">expr 1 + 4   # 回输出5<br></code></pre></td></tr></table></figure><p>需要注意的是对于操作符和操作数之间要有空格，对于在shell中有其他含义的操作符要加<code>\</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">expr 1+4  // 报错 1和+之间，+和4直接需要有空格隔开<br>expr 1 + 4 // 正确<br>expr 2 * 4 // 错误，*在shell中有其他含义<br>expr 2 \* 4 // 正确<br></code></pre></td></tr></table></figure><h3 id="方括号"><a href="#方括号" class="headerlink" title="方括号[]"></a>方括号[]</h3><p>现在更多的是采用<code>[]</code>的方式来执行数学表达式，它是兼通expr，也就是说expr的操作使用<code>[]</code>也能实现。所以更推荐使用<code>[]</code>而非expr，并且<code>[]</code>也比较易于使用，也不用担心会将操作符与shell中有特殊含义的符号混淆比如expr中的*号，看着也简洁。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">var1=$[ 1 * 4 ]<br>echo $var1<br></code></pre></td></tr></table></figure><h2 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h2><h3 id="查看退出码"><a href="#查看退出码" class="headerlink" title="查看退出码"></a>查看退出码</h3><p>shell中有一个专门的变量<code>$?</code>它保存的是上个命令的退出码。如果运行的是shell脚本那么上一个命令显然就是shell脚本最后执行的命令。以下是一些常见的退出码。</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240610215807838.png" alt="image-20240610215807838"></p><h3 id="exit命令"><a href="#exit命令" class="headerlink" title="exit命令"></a>exit命令</h3><p>在shell中也可以使用exit命令显示退出脚本，exit允许指定一个退出码，这和C语言main中的return很相似，C语言main函数返回的是一个退出码，通常是0表示没有错误，这也与shell类似。</p><h1 id="结构化命令"><a href="#结构化命令" class="headerlink" title="结构化命令"></a>结构化命令</h1><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>shell也支持条件控制if，通常用法是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">if-then</span><br>if command<br>then<br>commands<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">if-then-else</span><br>if command<br>then<br>commands1<br>else<br>commands2<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">if-then-elif-then-else</span><br>if command1<br>then<br>commands1<br>elif command2<br>then<br>commands2<br>else<br>commands3<br>fi<br></code></pre></td></tr></table></figure><p>这是常见的if用法，其中if-then也可以写成下面这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">if command1; then<br>commands1<br>elif command2; then<br>commands2<br>fi<br></code></pre></td></tr></table></figure><p>需要注意的是上面if后面接的是command也就是命令，而不是像其他编程语言一样接受一个不是true就是false的谓词。shell中的if会根据command命令的退出码来判断是否执行then后面的内容。换句话说，若command的退出码为0(command执行成功)用其他语言表示就是代表这个条件为真，那么执行这个条件之后的内容(也就是then之后的内容)，其余非0的退出码(command执行失败)均表示条件为假。下面是一些例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if aaa; then<br>echo &quot;command aaa exec suss&quot;<br>elif ls; then<br>echo &quot;command ls exec suss&quot;<br>else<br>echo &quot;none command exec suss&quot;<br>fi<br></code></pre></td></tr></table></figure><p>这里aaa是随便输入的，它不是命令，但执行它也会返回一个非0的退出码，所以aaa条件部分不会执行，而ls命令显然会执行成功，返回0退出码，故会输出”command ls exec suss”。</p><h2 id="test命令-更灵活使用if"><a href="#test命令-更灵活使用if" class="headerlink" title="test命令(更灵活使用if)"></a>test命令(更灵活使用if)</h2><p>test命令用于测试某个条件是否成立，若成立则返回0退出码，不成立则返回非0退出码，使用test我们就可以间接的使用shell中的if实现类似其他语言中的if的工作方式即通过条件真假来判断是否执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">test</span>测试变量时，表测试变量是否不为空，非空返回状态码0，空返回非0</span><br>val=&quot;&quot;<br>if test $val; then<br>ehco &quot;val has content&quot;<br>else<br>ehco &quot;val has not content&quot;  # val为空，这行会执行<br>fi<br><br>val=&quot;aaa&quot;<br>if test $val; then<br>ehco &quot;val has content&quot;# val非空，这行会执行<br>else<br>ehco &quot;val has not content&quot;  <br>fi<br></code></pre></td></tr></table></figure><p>shell也提供了更灵活使用test方式，也就是使用<code>[]</code>,注意与expr命令使用<a href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%5B%5D">方括号[]</a>作为替代的方式区别开来。注意command两侧有空格，即与中括号要有空格隔开。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition ]; then<br>command<br>fi<br></code></pre></td></tr></table></figure><h3 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h3><p>使用test常见的数值比较由下图列出。由因为单词缩写构成，eq(equal：等于),ge(greater equal：大于等于)，gt(greater than：大于)，le(less equal：小于等于)，lt(less than：小于)，ne(not equal：不等于)</p><h3 id=""><a href="#" class="headerlink" title=""></a><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240610225902566.png" alt="image-20240610225902566"></h3><h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>使用test常见的数值比较如下</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240610230308890.png" alt="image-20240610230308890"></p><h3 id="文件比较"><a href="#文件比较" class="headerlink" title="文件比较"></a>文件比较</h3><p>使用test常见的文件比较如下</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240610230520423.png" alt="image-20240610230520423"></p><h2 id="复合条件测试"><a href="#复合条件测试" class="headerlink" title="复合条件测试"></a>复合条件测试</h2><p>if允许使用复合条件测试，用法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ contition1 ] &amp;&amp; [ condition2 ] # and条件<br>[ contition1 ] || [ condition2 ] # 或条件<br></code></pre></td></tr></table></figure><h2 id="if-then高级特性"><a href="#if-then高级特性" class="headerlink" title="if-then高级特性"></a>if-then高级特性</h2><h3 id="使用双括号"><a href="#使用双括号" class="headerlink" title="使用双括号"></a>使用双括号</h3><p>双括号允许我们使用高级数学表达式，实际上就是其他编程语言常见的一些东西</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240610232434091.png" alt="image-20240610232434091"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">val=10<br>if (( $val ** 2 &gt;90)) # 10的平方是否大于90<br></code></pre></td></tr></table></figure><h3 id="双方括号"><a href="#双方括号" class="headerlink" title="双方括号"></a>双方括号</h3><p>针对字符串比较的高级特性，使用方法如下</p><blockquote><p>[[ expression ]]</p></blockquote><p>双方括号里的expression使用了test命令中采用的标准字符串比较。但它提供了test命令未提供的另一个特性一模式匹配(pattern matching)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [[ $USER ==r* ]]<br>then<br>echo &quot;Hello SUSER&quot;<br>else<br>echo &quot;Sorry,I do not know you&quot;<br>fi<br></code></pre></td></tr></table></figure><p>以上程序使用了regex表达式，意思是USER是否以是以r为开头的字符串</p><h2 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h2><p>case与if-then-elif-then效果类似，case一般用于if-else要写很长的情况也就是说有多个条件，类似于C语言中的switch-case语句。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">case variable in<br>pattern1 | pattern2) command1;;<br>pattern3) command2;;<br>*) default commands;;<br>esac<br></code></pre></td></tr></table></figure><p>variable会与模式相匹配，若匹配就会执行之后的command，其中pattern1 | pattern2表示只要匹配pattern1或pattern2中的一个模式就执行之后的命令。</p><p>下面是一个if-else改写成case的例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs shell">if SUSER &quot;rich&quot;<br>then<br>echo &quot;Welcome SUSER&quot;<br>echo &quot;Please enjoy your visit&quot;<br>elif SUSER &quot;barbara&quot;<br>then<br>echo &quot;Welcome SUSER&quot;<br>echo &quot;Please enjoy your visit&quot;<br>elif SUSER &quot;testing&quot;<br>then<br>echo &quot;Special testing account&quot;<br>elif SUSER &quot;jessica&quot;<br>then<br>echo &quot;Do not forget to logout when you&#x27;re done&quot;<br>else<br>echo &quot;Sorry,you are not allowed here&quot;<br>fi<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">case</span>改写</span><br>case SUSER in<br>rich | barbara)<br>echo &quot;Welcome,SUSER&quot;<br>echo &quot;Please enjoy your visit&quot;;;<br>testing)<br>echo &quot;Special testing account&quot;;;<br>jessica)<br>echo &quot;Do not forget to log off when you&#x27;re done&quot;;;<br>*)<br>echo &quot;Sorry,you are not allowed here&quot;;;<br>esac<br></code></pre></td></tr></table></figure><h2 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a>for命令</h2><p>shell中的循环语句使用的是for，其用法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in list; do<br>command<br>done<br></code></pre></td></tr></table></figure><h3 id="使用for命令从文件中读取"><a href="#使用for命令从文件中读取" class="headerlink" title="使用for命令从文件中读取"></a>使用for命令从文件中读取</h3><p>下面是一个从文件中获取值的例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for val in $(cat status)<br>echo $val<br>done<br></code></pre></td></tr></table></figure><p>status文件如下:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">aaa bbb<br>ccc ddd<br>eee<br></code></pre></td></tr></table></figure><p>执行这个脚本会发现输出如下</p><blockquote><p>aaa</p><p>bbb</p><p>ccc</p><p>ddd</p><p>eee</p></blockquote><h3 id="更改字段分隔符-IFS"><a href="#更改字段分隔符-IFS" class="headerlink" title="更改字段分隔符(IFS)"></a>更改字段分隔符(IFS)</h3><p>上节中的例子可以发现输出并没有像我们想象的那样一行一行的输出，这因为shell内部有个名为IFS(Internal Field Separator)的环境变量，中文名为内部字段分隔符，其默认值是空格，制表位，换行符。所以上面当shell识别到空格时它会以为是一个新的字段开始，就有了上面的输出，要实现每次读一行就要修改IFS变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">IFS.OLD=$IFS<br>IFS=$&#x27;\n&#x27;<br>for val in $(cat status)<br>echo $val<br>done<br>IFS=$IFS.OLD<br></code></pre></td></tr></table></figure><p>上面程序就会输出</p><blockquote><p>aaa bbb<br>ccc ddd<br>eee</p></blockquote><p>这也是我们期待的，同时上面程序也是推荐的做法，先使用IFS.OLD保存默认IFS变量，用完后在是IFS变量修改为默认值。</p><h2 id="while命令"><a href="#while命令" class="headerlink" title="while命令"></a>while命令</h2><p>while命令理解为是if与for的结合体，其用法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">while test command; do<br>commands<br>done<br></code></pre></td></tr></table></figure><h2 id="until命令"><a href="#until命令" class="headerlink" title="until命令"></a>until命令</h2><p>until命令与while命令相反但用法几乎一致，until命令是如果until后面的命令返回非0退出码则继续执行，而while则是要0的退出码才能继续执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">until test command; do<br>commands<br>done<br></code></pre></td></tr></table></figure><p>下面是while和until对比的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">var=100<br>until [ $var -eq 0 ]<br>echo $var<br>var=$[ $var - 1 ]<br>done<br><br>var=100<br>while [ $var -eq 0 ]<br>echo $var<br>var=$[ $var - 1 ]<br>done<br></code></pre></td></tr></table></figure><p>until部分程序的含义是如果var不等于0则输出，而while部分程序则是如果var等于0就输出</p><h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><h3 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h3><p>break命令若是单独使用则与C语言中break功能类似，表示退出最内层的循环。for,while,until均可以使用。不一样的是shell中break可以指定参数，说明退出哪个循环，默认情况下是1，代表但前最内层的循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">for（(a=1;a&lt;4;a++))<br>do<br>echo &quot;Outer loop:Sa&quot;<br>for（(b=1;b&lt;100;b++))<br>do<br>if sb -gt 4<br>then<br>break 2<br>fi<br>echo Inner loop:$b&quot;<br>done<br>done<br></code></pre></td></tr></table></figure><p>上面程序中<code>for（(b=1;b&lt;100;b++))</code>是最内层循环，<code>for（(a=1;a&lt;4;a++))</code>外层循环，break命令会把但前所在的循环当作第一层循环，在依次往外推，上面代码中break 2就表示退出地二层循环，对于break 2所在的循环而已第二层循环就是<code>for（(a=1;a&lt;4;a++))</code>。</p><h3 id="continue命令"><a href="#continue命令" class="headerlink" title="continue命令"></a>continue命令</h3><p>continue命令与break一样，在单独使用时与C语言中continue相似，但continue也可以指定继续往下执行哪一层循环。</p><h2 id="处理循环输出"><a href="#处理循环输出" class="headerlink" title="处理循环输出"></a>处理循环输出</h2><p>从上面可以看出for,while,until的结束都以<code>done</code>结尾，但我们通常要进行循环输出重定向是可以在<code>done</code>后面添加重定向命令，例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">for file in /home/rich/*<br>do<br>if [-d &quot;sfile&quot;<br>then<br>echo &quot;sfile is a directory&quot;<br>elif<br>echo &quot;sfile is a file&quot;<br>fi<br>done  &gt; output.txt<br></code></pre></td></tr></table></figure><p>上面程序表示将for循环的输出重定向到output.txt中，但不会影响后续输出。</p><h1 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h1><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><h3 id="读取参数"><a href="#读取参数" class="headerlink" title="读取参数"></a>读取参数</h3><p>在shell中命令行参数有特殊变量代替，$0代表程序名，$1是第一个参数，$2是第二个参数…$9是第九个参数，之后若超过两位数的参数需要加{}，比如${10},${11}代表第十个和第十一个参数,而不是$10,$11。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">test.sh</span><br>echo $10<br>echo $&#123;10&#125;<br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">sh test.sh 1 2 3 4 5 6 7 8 9 0</span><br>10<br>0<br></code></pre></td></tr></table></figure><p>若使用$10，shell会将<code>$10</code>分成两部分处理即<code>$1</code>和<code>0</code>。上面程序中$1是1，而0不处理直接输出所以<code>echo $10</code>输出是10。</p><h3 id="特殊参数变量"><a href="#特殊参数变量" class="headerlink" title="特殊参数变量"></a>特殊参数变量</h3><ul><li>$#：代表参数个数</li><li>$*：将命令行上提供的所有参数当作一个单词保存。</li><li>$@：将命令行上提供的所有参数当作同一字符串中的多个独立的单词</li></ul><p><code>$*</code>和<code>$@</code>的主要区别是，$*是一个整体，$@是一个个体使用for遍历时可以逐个输出命令行传过来的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">test.sh</span><br>for var in &quot;$*&quot;; do<br>echo <br></code></pre></td></tr></table></figure><h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><h3 id="getopt命令"><a href="#getopt命令" class="headerlink" title="getopt命令"></a>getopt命令</h3><p>getopt命令可以接受一系列任意形式的命令行选项和参数，并自动将它们转换成适当的格式。它的命令格式如下：</p><blockquote><p>getopt optstring parameters </p></blockquote><p>optstring是这个过程的关键所在。它定义了命令行有效的选项字母，还定义了哪些选项字母需要参数值。若选项值需要参数则在该选项后加<code>:</code>即可。例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">getopt ab:<span class="hljs-built_in">cd</span> -a -b <span class="hljs-built_in">test</span> -c test2 -d</span><br>-a -b test -c -d -- test2<br></code></pre></td></tr></table></figure><p>上面程序中只有b后面有:所以选项b需要参数，而c不需要所及即便我们写了<code>-c test2</code>getopt函数也知道-c是不需要参数的，所以把它当作普通参数。</p><p>值得注意的是getopt只是将它们转换成了适当的格式，实际命令参数并未改变，意思就是我们调用getopt，命令行参数仍未改变，要想在程序中改变命令行参数需要用到set命令，set命令的–选项会将命令参数替换为set命令的命令行值。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">test.sh</span><br>replace=$(getopt ab:cd &quot;$@&quot;)<br>echo &quot;param befor replace :$*&quot;<br>set -- $replace<br>echo &quot;------------------&quot;<br>echo &quot;param after replace :$*&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sh test.sh</span><br>param befor replace :-a -b test -c test1 -d test2<br>------------------<br>param after replace :-a -b test -c -d -- test1 test2<br></code></pre></td></tr></table></figure><p>明显可以看到getopt只是将命令行参数转换成适当的格式，并未改变命令行参数，而真正改变命令行参数的是<code>set --</code>命令</p><h3 id="getopts命令-getopt扩展"><a href="#getopts命令-getopt扩展" class="headerlink" title="getopts命令(getopt扩展)"></a>getopts命令(getopt扩展)</h3><h2 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h2><p>read命令读取用户输入，使用read可以从标准输入中读取也能从文件中读取</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unix编程</title>
    <link href="/geez6572/2023/09/28/Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/"/>
    <url>/geez6572/2023/09/28/Unix%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-Unix基础知识"><a href="#第一章-Unix基础知识" class="headerlink" title="第一章 Unix基础知识"></a>第一章 Unix基础知识</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><h1 id="第三章-文件IO"><a href="#第三章-文件IO" class="headerlink" title="第三章 文件IO"></a>第三章 文件IO</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>对于内核而言所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数，当打开或创建一个文件时，内核会向进程返回一个文件描述符，这也就理解了为什么使用read函数式需要先使用open函数，因为open函数会返回一个文件描述符。</p><h2 id="函数lseek"><a href="#函数lseek" class="headerlink" title="函数lseek"></a>函数lseek</h2><p>通常来说打开一个文件是若为指定<em>O_APPEND</em>选项，则其偏移量均为0。而lseek可以修改文件偏移量</p><h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>改变已打开的文件属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">int</span> cmd,...<span class="hljs-comment">/* int arg */</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> request, ...)</span><br></code></pre></td></tr></table></figure><h2 id="复制文件描述符dup和dup2"><a href="#复制文件描述符dup和dup2" class="headerlink" title="复制文件描述符dup和dup2"></a>复制文件描述符dup和dup2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br></code></pre></td></tr></table></figure><h1 id="第四章-文件和目录"><a href="#第四章-文件和目录" class="headerlink" title="第四章 文件和目录"></a>第四章 文件和目录</h1><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul><li><p>普通文件</p></li><li><p>目录文件</p></li><li><p>块特殊文件</p></li><li><p>字符特殊文件</p></li><li><p>FIFO</p><p>用于进程通信，通常也称作管道（pipe）</p></li><li><p>socket</p></li><li><p>符号链接</p></li></ul><h2 id="access函数"><a href="#access函数" class="headerlink" title="access函数"></a>access函数</h2><p><code>access</code>函数是一个用于检查调用进程是否对指定的文件具有特定访问权限的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">access</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">int</span> type)</span><br></code></pre></td></tr></table></figure><h2 id="umask函数"><a href="#umask函数" class="headerlink" title="umask函数"></a>umask函数</h2><p><code>umask</code> 函数是一个在 Unix 和类 Unix 操作系统中使用的系统调用，用于设置文件创建权限的掩码（umask），它会影响当前进程及其子进程创建新文件和目录时的默认权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">mode_t</span> <span class="hljs-title function_">umask</span><span class="hljs-params">(<span class="hljs-type">mode_t</span> cmask)</span>;<br></code></pre></td></tr></table></figure><p>通常在创建文件是都会指定权限(比如creat函数)，使用creat仅会指定文件的基本权限，但实际上文件最终创建后的权限会受umask影响。</p><h1 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>标准IO库(stdio)的IO操作都是围绕流进行的，而非文件描述符。可以将流理解为比文件描述符更高级的抽象。使用fopen函数可以打开一个流，与open函数不同fopen是标准IO库中的操作，它会返回一个FILE指针，通常来说FILE会包含以下这些信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> fd;                 <span class="hljs-comment">// 文件描述符</span><br>    <span class="hljs-type">char</span> *buffer;           <span class="hljs-comment">// 缓冲区</span><br>    <span class="hljs-type">size_t</span> buffer_size;     <span class="hljs-comment">// 缓冲区大小</span><br>    <span class="hljs-type">size_t</span> buffer_pos;      <span class="hljs-comment">// 当前缓冲区位置</span><br>    <span class="hljs-type">size_t</span> buffer_end;      <span class="hljs-comment">// 缓冲区中数据的结束位置</span><br>    <span class="hljs-type">int</span> flags;              <span class="hljs-comment">// 文件状态标志</span><br>    <span class="hljs-type">int</span> eof;                <span class="hljs-comment">// 文件结束标志</span><br>    <span class="hljs-type">int</span> error;              <span class="hljs-comment">// 错误标志</span><br>&#125; FILE;<br></code></pre></td></tr></table></figure><p>从结构体中也不难发现，FILE是包含文件描述符的，但有包含其他文件描述符以外的信息，用于方便高级操作，所以说FILE是比文件描述符更高级别的抽象。</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>这是流相对于文件描述符而言，提供的高级操作之一，缓冲区可以减少系统调用的次数以此提高效率。拿写来说我们写操作是先写入到缓冲区中，然后才会根据缓冲类型等到合适时机写入磁盘。</p><p>这里解释下为什么不直接写入磁盘(直接写入磁盘甚至还少一步操作)，因为这样可以减少系统调用次数，设想我们把写的数据先写到一个数组中，若数组较大，我们等到数组用完才开始执行系统调用写入磁盘这样我只用了一次系统调用，而直接写入磁盘的话那设想一种情况一次写入一个字节，若数组大小为1000，那么有缓冲区的写1000字节只需要执行一次系统调用，而直接写入要执行1000次系统调用。磁盘传输速率肯定是不变得一次传1000字节也好一次传一个字节传1000次也罢，速率是一样的。但1000次系统调用和1次系统调用相比就差很大了，尽管与写入磁盘操作比起来系统调用的时间很小，但对性能要求高的场景也是很有必要的。缓冲一般有以下三种类型：</p><ul><li><p>全缓冲</p><p>只有填满缓冲区后才开始进行实际的IO操作。</p></li><li><p>行缓冲</p><p>只有遇到换行符或者缓冲去已满才开始执行实际IO操作。</p></li><li><p>不带缓冲</p><p>不对IO进行缓冲。</p></li></ul><p>下面是一些跟缓冲有关的函数：</p><p>一般来说使用fopen和fwrite函数创建的流都会由标准io默认分配一个缓冲区，下面的函数是提供给用户自己指定缓冲区或设置缓冲去的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">setbuf</span><span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span>,<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> bu)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">setvbuf</span> <span class="hljs-params">(FILE *<span class="hljs-keyword">restrict</span>,<span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> buf,<span class="hljs-type">int</span> mode,<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>下面这个函数可以用来强制冲洗一个流，说直白点就是将在缓冲区的数据传入内核。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fflush</span><span class="hljs-params">(FILE* fp)</span>;<br></code></pre></td></tr></table></figure><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> bype)</span>;<br>FILE *<span class="hljs-title function_">freopen</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> pathname,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-keyword">restrict</span> type,FILE *<span class="hljs-keyword">restrict</span> p)</span>;<br>FILE *<span class="hljs-title function_">fdopen</span> <span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *type)</span>;<br></code></pre></td></tr></table></figure><p>(1)fopen函数打开路径名为pathname的一个指定的文件。<br>(2)freopen函数在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该流。若该流已经定向，则使用freopen清除该定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出或标准错误。<br>(3)fdopen函数取一个已有的文件描述符（我们可能从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到此文件描述符)，并使一个标准的I&#x2F;O流与该描述符相结合。此函数常用于由创建管道和网络通信通道函数返回的描述符。因为这些特殊类型的文件不能用标准I&#x2F;O函数fopen打开，所以我们必须先调用设备专用函数以获得一个文件描述符，然后用fdopen使一个标准VO流与该描述符相结合。</p><p>关闭流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE* fp)</span>;<br></code></pre></td></tr></table></figure><h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>一般进程终止可调用exit，_exit和_Exit或从main函数返回。三个退出函数的区别是exit会想进行一些清理比如关闭io操作之类的再进入内核，而_exit和_Exit函数则是立即进入内核。exit和main返回的区别是在main函数中exit和return函数功能是一样的，但在其他函数中exit会退出进程，而return只是结束这个函数而已。</p><h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个进程都会接收到一张环境表，该表是一个字符指针数组，要使用该表需要显示声明，像下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>** environ;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">while</span>(environ!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,*environ);<br>        environ++;<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是打印环境表的一段程序，这个输出通常和我们在shell中输出env的输出一致。</p><h2 id="进程内存空间布局"><a href="#进程内存空间布局" class="headerlink" title="进程内存空间布局"></a>进程内存空间布局</h2><p>进程内存空间布局一般包含以下几个段</p><ul><li>文本段：包含了进程运行的程序机器语言指令。文本段具有只读属性，以防止进程通过错误指针意外修改自身指令。因为多个进程可同时运行同一程序，所以又将文本段设为可共享，这样，一份程序代码的拷贝可以映射到所有这些进程的虚拟地址空间中。</li><li>初始化数据段：包含显式初始化的全局变量和静态变量。当程序加载到内存时，从可执行文件中读取这些变量的值。</li><li>未初始化数据段(bbs段)：包含了未进行显式初始化的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。将经过初始化的全局变量和静态变量与未经初始化的全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。</li><li>栈(stack)：是一个动态增长和收缩的段，由栈帧(stack frames)组成。系统会为每个当前调用的函数分配一个栈帧。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。</li><li>堆(heap)：是可在运行时（为变量）动态进行内存分配的一块区域。堆项端称作program break。对于初始化和未初始化的数据段而言，不太常用、但表述更清晰的称谓分别是用户初始化</li></ul><p>下面是内存布局图片</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240617190459856.png" alt="image-20240617190459856"></p><h1 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是半双工的(数据只能在一个方向上传输)，但其实现在管道是大部分是全双工的，只是为了可移植性而将全双工当作半双工使用(有点类似cpp中deque可以当作stack或queue使用)一般即使是全双工的也绝不会当作全双工使用。管道只能在两个具有公共祖先的进程中使用。最常见就是父进程fork一个子进程后通过管道给子进程传输数据，或者相反。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span>;<br></code></pre></td></tr></table></figure><p>pipe创建的两个文件描述符fd[0]是读端，fd[1]是写端。但向文件描述符fd[1]写入的会输出到fd[0]中，然后就能通过读取fd[0]来获取fd[1]中写入的数据。</p><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>有时被称为命名管道，上节讲到的pipe是未命名管道因此它只能在在两个具有公共祖先的进程中使用。而本节的FIFO可以使不相关的进程也能使用。FIFO事实上是一个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path,<span class="hljs-type">mode_t</span> mode)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">mkfifoat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path,<span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure><h1 id="tlpi-深入探究文件IO"><a href="#tlpi-深入探究文件IO" class="headerlink" title="(tlpi) 深入探究文件IO"></a>(tlpi) 深入探究文件IO</h1><h2 id="文件描述符和打开文件之间的关系"><a href="#文件描述符和打开文件之间的关系" class="headerlink" title="文件描述符和打开文件之间的关系"></a>文件描述符和打开文件之间的关系</h2><p>首先理解几个文件描述符相关的概念</p><ol><li><p>进程级文件描述符</p><p>针对每个<code>进程</code>，内核为其维护打开文件的描述符表。该表的每一条目都记录了单个文件描述符的相关信息。文件描述符是对进程而言的，所以每个进程中相同的文件描述符可能指向的是不同文件。</p></li><li><p>系统级打开文件表</p><p>内核对所有打开的文件维护有一个系统级的描述表格，因为是系统级别的所以所有的进程打开的文件都会记录在这里，即使是不同进程打开相同文件，或者是相同进程打开两次相同文件，都会在这里有一项记录。</p></li><li><p>文件系统的i-node表</p><p>每个文件系统都会为驻留其上的所有文件建立一个i-node表。这个对于每个文件来说是唯一的。里面通常存放了文件相关信息像文件类型，属性之类的。</p></li></ol><p>这里在例举几种会出现的在三者直接的情况。如下如图所示</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240609215057238.png" alt="image-20240609215057238"></p><ul><li><p>情况一</p><p>同一进程中不同的文件描述符指向同一个打开文件表的条目，如进程A中的文件描述符1和20都指向标号为23的打开文件表条目。出现这种情况的原因通常是调用dup,dup2,fcntl函数造成。</p></li><li><p>情况二</p><p>属于不同进程的文件描述符指向同一个打开文件表条目，如进程A的文件描述符2和进程B的文件描述符2指向标号为73的打开文件表条目。通常来说发生在fork调用或者进程间描述符传递。这里还是要注意上面说的，文件描述符是进程层面的东西，即便这里两个进程文件描述符相同也指向同一打开表条目，但这并不代表两个文件描述符是同一个描述符，上面A进程描述0和描述符1都有指向打开文件表，而进程B中的描述符0和1却没有指向就足以说明这点。再有若我们关闭进程B的文件描述符2，用图来说就是进程B的文件描述符2没有指向了，而进程A的文件描述符仍然指向打开表73。这也足以说明两个进程的相同编号的文件描述符指向同一打开表中的标号，也不代表它们是同一个文件描述符。</p></li><li><p>情况三</p><p>属于不同进程的文件描述符（或者属于相同进程的不同文件描述符）指向不同打开表标号，但这些不同打开表却指向相同的i-node节点，例如进程A中文件描述符0和进程B中文件描述符3指向了不同的打开表标号0和83，但却指向同一i-node节点1976（换句话说指向同一文件）。造成这种情况的原因，由系统打开表的概念也能解释，所有的进程打开的文件都会记录在这里，若两个进程都使用open打开同一个文件（或者同一进程调用两次open但打开的是同一文件），这里就会导致这些有open返回的文件描述符指向不同的打开表标号，但因为是同一个文件所以这些打开表标号都指向同同一i-node节点。</p></li></ul><h2 id="dup复制文件描述符"><a href="#dup复制文件描述符" class="headerlink" title="dup复制文件描述符"></a>dup复制文件描述符</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd)</span>; <span class="hljs-comment">// 复制oldfd返回复制后的文件描述符</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd,<span class="hljs-type">int</span> newfd)</span>;  <span class="hljs-comment">// 复制文件描述符，复制后的文件描述符编号由newfd指定，返回值指示成功或失败</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dup3</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd,<span class="hljs-type">int</span> newfd,<span class="hljs-type">int</span> flags)</span>; <span class="hljs-comment">// 与dup2功能相同，但多了flags参数，这是一个可以修改系统调用默认行为的位掩码</span><br></code></pre></td></tr></table></figure><h2 id="在文件特定偏移量处的I-O-pread-和pwrite"><a href="#在文件特定偏移量处的I-O-pread-和pwrite" class="headerlink" title="在文件特定偏移量处的I&#x2F;O:pread()和pwrite()"></a>在文件特定偏移量处的I&#x2F;O:pread()和pwrite()</h2><p>与read和write不同，pread和pwrite多了个offset参数，代表偏移量，表示在但前偏移量执行操作但不会改变文件当前的偏移量。而read和write是在当前文件描述符指向的系统打开表中的偏移量出执行操作。</p><h2 id="分散输入和集中输出-readv-和writev"><a href="#分散输入和集中输出-readv-和writev" class="headerlink" title="分散输入和集中输出:readv()和writev()"></a>分散输入和集中输出:readv()和writev()</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Returns number of bytes read,0 on EOF,or-1 on error</span><br>ssize t <span class="hljs-title function_">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov,<span class="hljs-type">int</span> ioucnt)</span>;<br><br><span class="hljs-comment">//Returns number of bytes written,or -1 on error</span><br>ssize t <span class="hljs-title function_">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *iov,<span class="hljs-type">int</span> ioucnt)</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iovec</span>&#123;</span><br><span class="hljs-type">void</span> *iov base;<br>size t iov_len;<br>&#125;;<br></code></pre></td></tr></table></figure><p>iov代表一组缓冲区，ioucnt代表缓冲区个数，struct iovec中base表示缓冲区指针，iov_len表示缓冲区长度。</p><p>使用readv时，会默认重iov[0]开始，依次往每个缓冲区写入数据。</p><p>使用writev时，与readv相反，它会从iov[0]开始将所有缓冲区拼接起来输出到fd中。</p><p>这两个函数也有指定偏移量的版本preadv和pwritev。</p><h2 id="载断文件：truncate-和ftruncate-系统调用"><a href="#载断文件：truncate-和ftruncate-系统调用" class="headerlink" title="载断文件：truncate()和ftruncate()系统调用"></a>载断文件：truncate()和ftruncate()系统调用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname,<span class="hljs-type">off_t</span> length)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">ftruncate</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,off t length)</span>;<br></code></pre></td></tr></table></figure><p>truncate()和ftruncate()系统调用将文件大小设置为length参数指定的值。若文件当前长度大于参数length,调用将丢弃超出部分，若小于参数length,调用将在文件尾部添加一系列空字节或是一个文件空洞。</p><p>两个函数区别是一个指定文件名，一个指定文件描述符。</p><h1 id="系统和进程信息"><a href="#系统和进程信息" class="headerlink" title="系统和进程信息"></a>系统和进程信息</h1><p>为了提供更为简便的方法来访问内核信息，许多现代UNIX实现提供了一个proc虚拟文件系统。该文件系统驻留于proc目录中，包含了各种用于展示内核信息的文件，并且允许进程通过常规文件I&#x2F;O系统调用来方便地读取，有时还可以修改这些信息。之所以将proc文件系统称为虚拟，是因为其包含的文件和子目录并未存储于磁盘上，而是由内核在进程访问此类信息时动态创建而成。</p><h2 id="进程相关信息"><a href="#进程相关信息" class="headerlink" title="进程相关信息"></a>进程相关信息</h2><p>在&#x2F;proc下有许多目录，有一部分目录是以进程pid命名的，它代表一个进程即&#x2F;proc&#x2F;pid，在&#x2F;proc&#x2F;pid下会包含该pid的进程相关信息，一般来说一个&#x2F;proc&#x2F;pid目录会包含以下信息。</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240613002052367.png" alt="image-20240613002052367"></p><h2 id="系统相关信息"><a href="#系统相关信息" class="headerlink" title="系统相关信息"></a>系统相关信息</h2><p>&#x2F;proc除了以进程pid命名的目录外，还有一些其他目录，通常表示系统信息</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240613003819185.png" alt="image-20240613003819185"></p><h1 id="文件IO缓冲"><a href="#文件IO缓冲" class="headerlink" title="文件IO缓冲"></a>文件IO缓冲</h1><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h1 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>mmap()系统调用在调用进程的虚拟地址空间中创建一个新内存映射。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习</title>
    <link href="/geez6572/2023/09/28/Vue%E5%AD%A6%E4%B9%A0/"/>
    <url>/geez6572/2023/09/28/Vue%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h1><h2 id="setup概述"><a href="#setup概述" class="headerlink" title="setup概述"></a>setup概述</h2><p>用于替代vue2中的选项是api的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;srcipt lang=&#x27;ts&#x27;&gt;<br>    data:&#123;<br>    <br>    &#125;<br>&lt;/srcipt&gt;<br></code></pre></td></tr></table></figure><h2 id="watch监视"><a href="#watch监视" class="headerlink" title="watch监视"></a>watch监视</h2><p>用</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Linux学习</title>
    <link href="/geez6572/2023/09/28/linux%E5%AD%A6%E4%B9%A0/"/>
    <url>/geez6572/2023/09/28/linux%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="linux命令"><a href="#linux命令" class="headerlink" title="linux命令"></a>linux命令</h1><h2 id="xprop-命令-捕捉窗口信息"><a href="#xprop-命令-捕捉窗口信息" class="headerlink" title="xprop 命令(捕捉窗口信息)"></a>xprop 命令(捕捉窗口信息)</h2><p>获取窗口名称</p><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>查找命令</p><h2 id="shuf命令"><a href="#shuf命令" class="headerlink" title="shuf命令"></a>shuf命令</h2><p>于创建随机排列（shuffle）的输出。<code>shuf</code> 可以接受输入数据（通常是文件名或由其他命令生成的列表），然后输出这些数据的随机顺序排列。这个工具在需要随机选择或打乱顺序的场景中非常有用。</p><h2 id="fc-list命令-查看字体"><a href="#fc-list命令-查看字体" class="headerlink" title="fc-list命令(查看字体)"></a>fc-list命令(查看字体)</h2><h2 id="xdg-mime-文件默认打开方式相关"><a href="#xdg-mime-文件默认打开方式相关" class="headerlink" title="xdg-mime(文件默认打开方式相关)"></a>xdg-mime(文件默认打开方式相关)</h2><h2 id="du-disk-usage-命令"><a href="#du-disk-usage-命令" class="headerlink" title="du(disk usage)命令"></a>du(disk usage)命令</h2><p><code>du</code>（disk usage）是一个在 Unix 和 Unix-like 操作系统中用来估计文件或目录在磁盘上的所占空间的命令行工具。它显示了指定文件或目录使用的字节数，并且可以递归地显示其所有子目录和文件的磁盘使用情况。</p><h2 id="df-disk-free-命令"><a href="#df-disk-free-命令" class="headerlink" title="df(disk free)命令"></a>df(disk free)命令</h2><p><code>df</code>（disk free）是 Unix 和类 Unix 操作系统中的一个命令行工具，用于显示系统中磁盘空间的使用情况。它可以报告文件系统的总容量、已用空间、剩余空间以及其他相关信息。</p><h2 id="netstat和ss命令"><a href="#netstat和ss命令" class="headerlink" title="netstat和ss命令"></a>netstat和ss命令</h2><p><code>netstat</code> 和 <code>ss</code> 是两个用于查看网络连接和统计信息的命令行工具。两者都提供了强大的网络监控和调试能力，但 <code>ss</code> 因其更快的性能和现代的特性，正在逐渐成为网络管理的首选工具。</p><h2 id="lsof命令"><a href="#lsof命令" class="headerlink" title="lsof命令"></a>lsof命令</h2><p><code>lsof</code>（List Open Files）是一个用于列出当前系统上所有打开文件的命令行工具。在 Unix 和 Linux 系统中，几乎所有的资源（包括常规文件、目录、网络套接字、设备等）都被视为文件。因此，<code>lsof</code> 可以用于多种用途，例如排查网络连接、监控系统资源、检测进程活动等。</p><h1 id="linux工具"><a href="#linux工具" class="headerlink" title="linux工具"></a>linux工具</h1><h2 id="rofi"><a href="#rofi" class="headerlink" title="rofi"></a>rofi</h2><p>rofi</p><h2 id="imagemagick工具"><a href="#imagemagick工具" class="headerlink" title="imagemagick工具"></a>imagemagick工具</h2><p>图片编辑</p><h1 id="linux环境变量"><a href="#linux环境变量" class="headerlink" title="linux环境变量"></a>linux环境变量</h1><h2 id="TERM变量"><a href="#TERM变量" class="headerlink" title="TERM变量"></a>TERM变量</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>lua语言</title>
    <link href="/geez6572/2023/09/28/lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <url>/geez6572/2023/09/28/lua%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="类型和值"><a href="#类型和值" class="headerlink" title="类型和值"></a>类型和值</h2><p>lua是一种动态类型语言，lua有8中基本数据类型:nil(空)，boolean(布尔),number(数值)，string(字符串)，userdata(用户数据)，function(函数)，thread(线程),table(表)。可以通过type函数判断类型。</p><h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>用于与其他类型进行区分，表示无效值</p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>含两个值true和false，在lua中布尔值不是判断条件的唯一类型，任何值都能表示条件<br>lua也支持逻辑远算符，与大多语言不同的是lua的逻辑运算符是其英文单词“and,or,not”,分别表示与或非。</p><h2 id="lua解释器"><a href="#lua解释器" class="headerlink" title="lua解释器"></a>lua解释器</h2><p>lua与shell和python一样是解释型脚本语言，lua解释器支持参数传递，参数会传入arg全局变量中，比如当我们执行以下脚本时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lua 脚本名称 arg1 arg2 ....<br></code></pre></td></tr></table></figure><p>解释器会将用索引0保存脚本名称，即arg[0]&#x3D;脚本名称，而位于脚本之后的参数依次保存到arg[1],arg[2]…中，脚本之前的参数则保存到arg[-1],arg[-2]…中。比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lua -e &quot;sin=math.sin&quot; test.lua a b<br></code></pre></td></tr></table></figure><p>此时解释器会按照如下方式获取参数</p><blockquote><p>arg[-3]&#x3D;”lua”<br>arg[-2]&#x3D;”-e”<br>arg[-1]&#x3D;”sin&#x3D;math.sin”<br>arg[0]&#x3D;”test.lua”<br>arg[1]&#x3D;”a”<br>arg[2]&#x3D;”b”</p></blockquote><p>不过通常情况下负向索引用的几乎很少，正向索引使用较多</p><h1 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h1><h2 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h2><p>lua中整数和浮点型属于number类型，当然也可以使用math.type()函数进一步区分，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-built_in">math</span>.<span class="hljs-built_in">type</span>(<span class="hljs-number">10</span>)  <span class="hljs-comment">-- integer</span><br><span class="hljs-built_in">math</span>.<span class="hljs-built_in">type</span>(<span class="hljs-number">10.0</span>)  <span class="hljs-comment">--double</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Unix网络编程-1</title>
    <link href="/geez6572/2023/09/28/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%B71%EF%BC%89/"/>
    <url>/geez6572/2023/09/28/unix%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8D%B71%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-TCP-IP简介"><a href="#第一章-TCP-IP简介" class="headerlink" title="第一章 TCP&#x2F;IP简介"></a>第一章 TCP&#x2F;IP简介</h1><h1 id="第三章-套接字编程简介"><a href="#第三章-套接字编程简介" class="headerlink" title="第三章 套接字编程简介"></a>第三章 套接字编程简介</h1><h2 id="htons函数"><a href="#htons函数" class="headerlink" title="htons函数"></a>htons函数</h2><p>h代表host，n带变network，s代表short</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">htons</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> hostshort)</span>;<br></code></pre></td></tr></table></figure><p>网络字节序是大端字节序（Big Endian）的一种形式。</p><p>而主机字节序是按照本地机器的硬件规定的字节顺序进行排列。有大端也有小端</p><p>htons函数用于将主机字节序的16位整数转换为网络字节序（大端字节序）。</p><p>通常来说若主机字节序也是大端字节序则不必进行转换，使用htons可以提高系统可移植性</p><p>其他相关函数还有：</p><ul><li>htonl</li><li>ntohs</li><li>ntohl</li></ul><h1 id="第四章-基本套接字编程"><a href="#第四章-基本套接字编程" class="headerlink" title="第四章 基本套接字编程"></a>第四章 基本套接字编程</h1><h2 id="端口号分类"><a href="#端口号分类" class="headerlink" title="端口号分类"></a>端口号分类</h2><p>端口号是一个 16 位的数字，因此其范围从 0 到 65535。根据用途和分配方式，可以将端口号分为以下几类：</p><ul><li><strong>知名端口（Well-known Ports）</strong>：0 - 1023</li><li><strong>注册端口（Registered Ports）</strong>：1024 - 49151</li><li><strong>动态或私有端口（Dynamic or Private Ports）</strong>：49152 - 65535</li></ul><p>知名端口好0-1023通常由内核控制，也就是说但你需要使用bind函数绑定0-1023中的端口，你需要有root用户权限。</p><h1 id="第六章-IO复用技术"><a href="#第六章-IO复用技术" class="headerlink" title="第六章 IO复用技术"></a>第六章 IO复用技术</h1><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><h2 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h2><h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><p>关于epoll函数为什么要在使用</p><h1 id="第七章-套接字选项"><a href="#第七章-套接字选项" class="headerlink" title="第七章 套接字选项"></a>第七章 套接字选项</h1><h2 id="setsockopt和getscokopt"><a href="#setsockopt和getscokopt" class="headerlink" title="setsockopt和getscokopt"></a>setsockopt和getscokopt</h2><p>用于设置和获取套接字选项</p><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>file control，fcntl函数可以执行各种文件描述符操作，因为socket本身也就是一个文件描述符，所以fcntl也能够为socket设置部分选项，尽管没有setsocket那么全</p><h1 id="第八章-基本UDP套接字"><a href="#第八章-基本UDP套接字" class="headerlink" title="第八章 基本UDP套接字"></a>第八章 基本UDP套接字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>UDP与TCP不同提供的是不可靠的传输，故使用UDP无须建立连接，客户端只需通过sendto直接发送数据即可，服务器通过recvfrom获取sendto发送的数据。</p><h2 id="sendto和recvfrom函数"><a href="#sendto和recvfrom函数" class="headerlink" title="sendto和recvfrom函数"></a>sendto和recvfrom函数</h2><h1 id="第九章-sctp套接字编程"><a href="#第九章-sctp套接字编程" class="headerlink" title="第九章 sctp套接字编程"></a>第九章 sctp套接字编程</h1><p>暂时不学</p><h1 id="第十章-sctp客户端-服务器实例"><a href="#第十章-sctp客户端-服务器实例" class="headerlink" title="第十章 sctp客户端&#x2F;服务器实例"></a>第十章 sctp客户端&#x2F;服务器实例</h1><p>暂时不学</p><h1 id="第十一章-名字与地址转换"><a href="#第十一章-名字与地址转换" class="headerlink" title="第十一章 名字与地址转换"></a>第十一章 名字与地址转换</h1><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>也就是DNS，即域名到ip地址的映射，linux中DNS服务器通常存放在<code>/etc/resolv.conf</code>中。</p><p><code>/etc/hosts</code>用于静态主机映射，常见有将localhost映射为127.0.0.1。</p><h2 id="getservbyname和getservbyport函数"><a href="#getservbyname和getservbyport函数" class="headerlink" title="getservbyname和getservbyport函数"></a>getservbyname和getservbyport函数</h2><p>与域名映射到ip类似，为了方便记住某个服务，操作系统也提供了名字到端口的映射存放在<code>/etc/services</code>中</p><p>getservbyname函数通过名字查找某个服务，getservbyport则是通过某个端口查找服务</p><h1 id="第十三章-守护进程和inetd超级服务器"><a href="#第十三章-守护进程和inetd超级服务器" class="headerlink" title="第十三章 守护进程和inetd超级服务器"></a>第十三章 守护进程和inetd超级服务器</h1><h2 id="创建守护程序"><a href="#创建守护程序" class="headerlink" title="创建守护程序"></a>创建守护程序</h2><p>守护进程是一种在后台运行的特殊进程，通常用于执行长期运行的服务任务，如监听网络请求或管理系统日志。</p><p>以下是将一个C程序变成守护进程通常需要执行的步骤：</p><ol><li><strong>创建子进程</strong>： 使用 <code>fork()</code> 创建一个新的子进程。通常，父进程会退出，让子进程继续作为守护进程运行。</li><li><strong>在子进程中创建新的会话</strong>： 使用 <code>setsid()</code> 创建一个新的会话，并成为该会话的领头进程。这使得守护进程与终端脱离关联。</li><li><strong>改变工作目录</strong>： 使用 <code>chdir(&quot;/&quot;)</code> 将当前工作目录改变到根目录。这是为了防止守护进程占用文件系统空间，导致文件系统无法卸载。</li><li><strong>重设文件权限掩码</strong>： 设置文件权限掩码以防止文件和目录的权限继承。</li><li><strong>关闭打开的文件描述符</strong>： 关闭所有非必要的文件描述符，或者将标准输入、输出和错误重定向到 <code>/dev/null</code>。</li><li><strong>处理僵尸进程</strong>： 如果守护进程创建了子进程，需要适当地处理它们，以避免僵尸进程的产生。</li></ol><p>上述就是创建守护进程的一般过程，这里说下第五步的技巧，关闭所有文件描述符后，应为open函数打开文件所创建的文件描述符为第一个可用文件描述符，所以在我们关闭所有文件描述符后第一个可用的文件描述符自然就是0，这是连续调用3次open函数就分配了0，1，2三个文件描述符，这是标准输入，标准输出，标准错误就被重定向到了<code>/dev/null</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;MAXFD;++i)<br>    close(i);<br>open(<span class="hljs-string">&quot;/dev/null&quot;</span>,O_RDONLY);<br>open(<span class="hljs-string">&quot;/dev/null&quot;</span>,O_RDWD);<br>open(<span class="hljs-string">&quot;/dev/null&quot;</span>,O_RDWD);<br></code></pre></td></tr></table></figure><h1 id="第十四章-高级IO函数"><a href="#第十四章-高级IO函数" class="headerlink" title="第十四章 高级IO函数"></a>第十四章 高级IO函数</h1><h2 id="recv和send函数"><a href="#recv和send函数" class="headerlink" title="recv和send函数"></a>recv和send函数</h2><h2 id="readv和writev函数"><a href="#readv和writev函数" class="headerlink" title="readv和writev函数"></a>readv和writev函数</h2><h2 id="recvmsg和sendmsg函数"><a href="#recvmsg和sendmsg函数" class="headerlink" title="recvmsg和sendmsg函数"></a>recvmsg和sendmsg函数</h2><h1 id="第十五章-UNIX域协议"><a href="#第十五章-UNIX域协议" class="headerlink" title="第十五章 UNIX域协议"></a>第十五章 UNIX域协议</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Uix域协议并不是一个实际的协议族，而是在单个主机上执行客户&#x2F;服务器通信的一种方法，在单个主机上通信其实换句话说就是进程之间的通信。</p><h2 id="描述符传递"><a href="#描述符传递" class="headerlink" title="描述符传递"></a>描述符传递</h2><p>我们知道子进程会继承父进程文件描述符，换句话说父进程将自己文件描述符传递给了子进程，那么在非父子进程中如何进行文件描述符的传递呢？</p><p>两个进程传递文件描述符操作如下：</p><ol><li>创建一个字节流或数据报的Unix套接字</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebServer项目</title>
    <link href="/geez6572/2023/09/28/webserver%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB/"/>
    <url>/geez6572/2023/09/28/webserver%E9%A1%B9%E7%9B%AE%E8%A7%A3%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="buffer设计"><a href="#buffer设计" class="headerlink" title="buffer设计"></a>buffer设计</h1><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">char</span>&gt; buffer_;<br>  std::atomic&lt;std::<span class="hljs-type">size_t</span>&gt; readPos_;<br>  std::atomic&lt;std::<span class="hljs-type">size_t</span>&gt; writePos_;<br></code></pre></td></tr></table></figure><p>使用vector容器代表缓冲区，readPos_表示读到某个位置，weiterPos_表示上次写的位置。</p><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::ReadFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>这里之所以取名<code>ReadFd</code>是因为对缓冲去而言，它是要写入肯定需要数据，<code>ReadFd</code>表示缓冲区要从文件描述符中读取数据，写入缓冲区，返回值是读取的长度(同时也是写入缓冲区的长度)。</p><p>写入缓冲去会涉及到缓冲区扩充问题(也就是vector扩容)，因为要确保缓冲区能够接受所有从fd中读取的数据。</p><h3 id="读取缓冲区"><a href="#读取缓冲区" class="headerlink" title="读取缓冲区"></a>读取缓冲区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::WriteFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>这个也是同理，对缓冲去而已，若要读取缓冲区，对缓冲区而已就是往文件描述符中写入数据。</p><h1 id="log设计"><a href="#log设计" class="headerlink" title="log设计"></a>log设计</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>log为系统日志，在系统中只有一份，故log采用了单例设计模式。</p><h2 id="数据-1"><a href="#数据-1" class="headerlink" title="数据"></a>数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> LOG_PATH_LEN = <span class="hljs-number">256</span>;  <span class="hljs-comment">//日志路径最大值</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> LOG_NAME_LEN = <span class="hljs-number">256</span>;  <span class="hljs-comment">//  日志名最大值</span><br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_LINES = <span class="hljs-number">50000</span>;   <span class="hljs-comment">// 日志最大存储</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path_;<span class="hljs-comment">// 日志路径</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *suffix_;<span class="hljs-comment">// </span><br><br>  <span class="hljs-type">int</span> MAX_LINES_;<br><br>  <span class="hljs-type">int</span> lineCount_;<br>  <span class="hljs-type">int</span> toDay_;<br><br>  <span class="hljs-type">bool</span> isOpen_;<br><br>  Buffer buff_;<br>  <span class="hljs-type">int</span> level_;<br>  <span class="hljs-type">bool</span> isAsync_;<br><br>  FILE *fp_;<br>  std::unique_ptr&lt;BlockDeque&lt;std::string&gt;&gt; deque_;<br>  std::unique_ptr&lt;std::thread&gt; writeThread_;<br>  std::mutex mtx_;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>搜索引擎使用技巧</title>
    <link href="/geez6572/2023/09/28/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/geez6572/2023/09/28/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="限定词"><a href="#限定词" class="headerlink" title="限定词"></a>限定词</h2><p>在搜索是我们有时可能需要搜索包含完全包含我们想要搜索的字符串的内容，但搜索引擎的搜索方式是模糊匹配他会将一些类似的也列出来，例如我想要搜索<code>易阳千喜</code>，这时会发现搜到的全是<code>易烊千玺</code>，很难找到我们想要的，这是可以限定搜索引擎就搜索<code>易阳千喜</code>，不需要模糊匹配。具体方式为在关键字两侧加双引号<code>&quot;&quot;</code>。</p><h2 id="限定标题"><a href="#限定标题" class="headerlink" title="限定标题"></a>限定标题</h2><p>这个功能限定搜索内容必须出现在标题。方式为在被搜索的内容前加<code>intitle:搜索内容</code>。也可配合上面限定词使用<code>intitle:&quot;搜索内容&quot;</code>。</p><h2 id="限定标题出现多个关键字"><a href="#限定标题出现多个关键字" class="headerlink" title="限定标题出现多个关键字"></a>限定标题出现多个关键字</h2><p>可以是搜索内容包含多个关键字，使用方法为<code>allintitle:内容1 内容2...</code>.</p><h2 id="限定文章内容"><a href="#限定文章内容" class="headerlink" title="限定文章内容"></a>限定文章内容</h2><p>这个功能限定搜索内容必须出现在文章中，使用方法为<code>intext:内容</code></p><h2 id="限定在url"><a href="#限定在url" class="headerlink" title="限定在url"></a>限定在url</h2><p>限定内容只出现在指定url中，例如搜索url中包含cctv内容，我们可以使用<code>inurl:cctv</code>，这样搜索出来的结果是所有url中包含cctv的内容，我们可以搜索url中包含cctv，关键字为易烊千玺的内容，<code>易烊千玺 inurl:cctv</code>。<code>inurl:</code>后面可以接网站也可以想例子中一样接某个关键字</p><h2 id="限定网站"><a href="#限定网站" class="headerlink" title="限定网站"></a>限定网站</h2><p>上面仅限定了url中出现的内容，就是只要是url中包含cctv就行，但我们想要搜索某个网站下的内容时就可以使用<code>site</code>关键字，<code>site:</code>后面必须接一个完整的域名。</p><h2 id="搜索指定尺寸图片"><a href="#搜索指定尺寸图片" class="headerlink" title="搜索指定尺寸图片"></a>搜索指定尺寸图片</h2><p>使用<code>imagesize:AxB</code>可以搜索图片大小为AxB的图片。</p><h2 id="搜索文档"><a href="#搜索文档" class="headerlink" title="搜索文档"></a>搜索文档</h2><p>使用<code>内容 filetype:pdf</code>，pdf可以替换为其他文件后缀入doc,ppt等，将搜到所有文档类型为pdf的文档。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法技巧</title>
    <link href="/geez6572/2023/09/28/%E7%AE%97%E6%B3%95/"/>
    <url>/geez6572/2023/09/28/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>异或运算符有以下三个基本特征：</p><ol><li>任何数和 0 做异或运算，结果仍然是原来的数，即 a^0&#x3D;a。</li><li>任何数和其自身做异或运算，结果是0，即a^a&#x3D;0。</li><li>异或运算满足交换律和结合律，即a^b^c&#x3D;a^c^b&#x3D;a^(b^c)…。</li></ol><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h3><p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p><p><strong>示例 1 ：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [2,2,1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[4,1,2,1,2]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：nums <span class="hljs-operator">=</span> [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>这里就可以利用异或运算特性，我们把所有元素进行异或运算，那么根据交换律我们把所有相同的元素先进行异或运算，由于相同的元素均出现两次，那么最终的到的肯定是<code>0^0....^0^rs</code> 其中rs是只出现过一次的数字即为答案。</p><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>常用于数组区间修改，单点查询。差分数组的性质是，当我们希望对原数组的某一个区间 [l,r] 施加一个增量inc 时，差分数组 d 对应的改变是：d[l] 增加 inc，d[r+1] 减少 inc。差分数组与前缀和是逆向关系，如下图。所以对于区间累加而言我们对区间起点 d[l] 增加 inc，那么在我们使用前缀和恢复原数组时 [l,len(d)-1]这个区间都会增加 inc，但我们希望的是只对区间[l,r]生效所以我们要 对 d[r+1] 减少 inc 这样就实现了区间的累加。</p><p><img src="/geez6572/home/ce/.config/Typora/typora-user-images/image-20240911132108274.png" alt="image-20240911132108274"></p><h3 id="1109-航班预订统计"><a href="#1109-航班预订统计" class="headerlink" title="1109. 航班预订统计"></a><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h3><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。  有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] &#x3D; [first_i, last_i, seats_i] 意味着在从 first_i 到 last_i （包含 first_i 和 last_i ）的 每个航班 上预订了 seats_i 个座位。  请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><p><strong>示例 1：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5<br>输出：[10,55,45,25,25]<br>解释：<br>航班编号        1   2   3   4   5<br>预订记录 1 ：   10  10<br>预订记录 2 ：       20  20<br>预订记录 3 ：       25  25  25  25<br>总座位数：      10  55  45  25  25<br>因此，answer = [10,55,45,25,25]<br></code></pre></td></tr></table></figure><p>这就是典型的区间累加问题，我们可以使用差分来解题。设有差分数组diff，对于题目中bookings[i],我们可以看作是对区间[bookings[i][0],bookings[i][1]]增加bookings[i][2]。</p><p>所以只需要对diff[bookings[i][0]-1]+bookings[2]，对diff[bookings[i][1]]-bookings[2]，注意航班是从1开始而数组下标从0开始。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">corpFlightBookings</span><span class="hljs-params">(bookings [][]<span class="hljs-type">int</span>, n <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br>diff := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> bookings &#123;<br>diff[v[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>] += v[<span class="hljs-number">2</span>]<br>diff[v[<span class="hljs-number">1</span>]] -= v[<span class="hljs-number">2</span>]<br>&#125;<br>rs := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br>rs[<span class="hljs-number">0</span>] = diff[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(rs); i++ &#123;<br>rs[i] = diff[i] + rs[i<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">return</span> rs<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/geez6572/2023/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    <url>/geez6572/2023/09/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络自顶向下方法"><a href="#计算机网络自顶向下方法" class="headerlink" title="计算机网络自顶向下方法"></a>计算机网络自顶向下方法</h1><h2 id="第一章-计算机网络和internet网"><a href="#第一章-计算机网络和internet网" class="headerlink" title="第一章 计算机网络和internet网"></a>第一章 计算机网络和internet网</h2><h3 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h3><p>物理层：提供传输功能，在线路上传输bit。</p><p>链路层：在相邻两点间传输以帧为单位的数据。</p><p>网络层：在端到端之间传输以分组为单位数据。</p><p>传输层：在进程到进程之间传输以报文段为单位的数据，将不可靠通信变成可靠的。</p><p>应用层：提供特殊的网络应用服务。</p><h2 id="第二章-应用层"><a href="#第二章-应用层" class="headerlink" title="第二章 应用层"></a>第二章 应用层</h2><h3 id="socket概述"><a href="#socket概述" class="headerlink" title="socket概述"></a>socket概述</h3><p>socket是一个位于传输层的api，socket表现为一个整数(在linux上称文件描述符)，对于TCP而言socket实际上是一个代表4元组的<code>本地意义的标识</code>。</p><ul><li>4元组：源IP，源port，目标IP，目标port</li><li>使用socket唯一指定了一个会话(两个进程之间的会话)</li><li>不必每一个报文都发送指定4元组，而只需发送标识即socket</li><li>与文件原理类似，打开一个文件后，我们不必每次都使用文件路径访问该文件，而是使用该文件描述符。</li><li>socket使用简单，便于管理；我们使用socket后在应用层向传输层传递数据是不必再传输IP+Port而是传输这个socket即可，这样就减少了层间传输的数据。</li></ul><p>在UDP中由于UDP是无连接的，不存在会话关系并且每次传输的对象可能不一样，所以socket在UDP表现为一个代表2元组的<code>本地意义的标识</code>。</p><ul><li>2元组：目标IP，目标port</li></ul><h2 id="第三章-传输层"><a href="#第三章-传输层" class="headerlink" title="第三章 传输层"></a>第三章 传输层</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/geez6572/2023/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/geez6572/2023/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cmake学习</title>
    <link href="/geez6572/2023/09/27/cmake/"/>
    <url>/geez6572/2023/09/27/cmake/</url>
    
    <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="命令调用"><a href="#命令调用" class="headerlink" title="命令调用"></a>命令调用</h2><p>CMake的命令调用类似于其他编程语言中的函数调用，但语法有些不同。先书写命令名称，其后跟括号括起来的命令参数。比如message(输出到标准输出)命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(a b c) <span class="hljs-comment">#输出a b c</span><br></code></pre></td></tr></table></figure><h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><h3 id="引号参数"><a href="#引号参数" class="headerlink" title="引号参数"></a>引号参数</h3><p>也就是使用引号包裹的参数，它是一个整体。值得注意的是若引号中有换行也会别识别，所以因为代码长而想要换行显示，但又不希望参数中包含换行符的话就要使用<code>\</code>。例如</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;</span><br><span class="hljs-string">a \</span><br><span class="hljs-string">b</span><br><span class="hljs-string">c&quot;</span>)<br><br><span class="hljs-comment">#输出</span><br>a b<br>c<br></code></pre></td></tr></table></figure><p>由输出不难看出b和c中有换行也不纳入了参数之中，而a和b之间虽然有换行但我们使用了<code>\</code>避免换行符纳入参数。</p><h3 id="非引号参数"><a href="#非引号参数" class="headerlink" title="非引号参数"></a>非引号参数</h3><p>非引号参数自然指未被引号包裹的参数。这种参数中不能包含任何空白符，也不能包含圆括号、#符号、双引号和反斜杠，除非经过转义。非引号参数也支持变量引用和转义字符。</p><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>CMake变量引用形式为${变量}，即在$符号后面使用一对花括号包裹变量名。CMake变量引用可用在引号参数和非引号参数中，CMake会将其替换为对应变量的值。若变量名未定义，CMake 并不会报错，而是将其替换为空字符串。另外，变量引用还支持嵌套的递归引用，如下所示</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(var_a hello)<br><span class="hljs-keyword">set</span>(var_b a)<br><span class="hljs-keyword">message</span>(<span class="hljs-variable">$&#123;var_$&#123;var_b&#125;</span>&#125;)<br><span class="hljs-comment"># $&#123;var_B&#125;-&gt;a</span><br><span class="hljs-comment"># $&#123;var_$&#123;var_b&#125;&#125;-&gt;$&#123;var_a&#125;</span><br></code></pre></td></tr></table></figure><h3 id="括号参数"><a href="#括号参数" class="headerlink" title="括号参数"></a>括号参数</h3><p>与引号参数一样，CMake的括号参数也会作为一个整体传递给命令。括号参数类似C++11中的原始字符串字面量（raw string literal），通过自定义的特殊括号将原始文本包括在其中。它不处理文本中的任何特殊字符（包括转义字符）或变量引用语法，直接保留原始文本。与引号不同括号参数即使使用<code>\</code>也会被当成参数一部分。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">message</span>([===[<br>aaa<br>bbb \<br>ccc<br>]===])<br></code></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>函数作用域。在用户自定义的函数命令中会有一个独立的作用域。默认情况下，函数内定义的变量只在函数内部或函数中调用的其他函数中可见。</p><p>目录作用域。对于CMake的目录程序而言，每一个目录层级，都有它的一个作用域。子目录的程序被执行前，会先将父目录作用域中的所有变量复制一份到子目录的作用域中。因此，子目录的程序可以访问但无法修改父目录作用域中的变量。</p><h3 id="定义普通变量"><a href="#定义普通变量" class="headerlink" title="定义普通变量"></a>定义普通变量</h3><p>定义普通变量形式如下。值参数也可以被省略，此时，该变量会从当前作用域中移除，相当于对该变量调用了unset命令。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(&lt;变量&gt; &lt;值&gt;... [PARENT_SCOPE])<br></code></pre></td></tr></table></figure><h3 id="定义缓存变量"><a href="#定义缓存变量" class="headerlink" title="定义缓存变量"></a>定义缓存变量</h3><p>缓存变量一般应用于目录程序中，便于对构建过程的一些配置进行持久化。因为缓存变量具有全局的作用域，也就不需要 PARENT_SCOPE参数了。定义缓存变量方式如下</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(&lt;变量&gt; &lt;值&gt;... CACHE &lt;变量类型&gt; &lt;变量描述&gt; [FORCE])<br></code></pre></td></tr></table></figure><h3 id="定义环境变量"><a href="#定义环境变量" class="headerlink" title="定义环境变量"></a>定义环境变量</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(ENV&#123;&lt;环境变量&gt;&#125; [&lt;值&gt;])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
